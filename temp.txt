
bin/LTZVisor.elf:     file format elf32-littlearm


Disassembly of section .text:

1c000000 <_reset_handler>:

.globl _reset_handler
_reset_handler:

	/** Run CPU0 and stuck other CPUs */
	bl	get_cpu_id
1c000000:	eb000038 	bl	1c0000e8 <get_cpu_id>
	cmp	r0, #0		@ CPU0?
1c000004:	e3500000 	cmp	r0, #0
	bne	__stuck_loop
1c000008:	1a000035 	bne	1c0000e4 <__stuck_loop>

1c00000c <__setup_CPU>:
__start_secure_core:

	/** Set CPU State */
__setup_CPU:
	/* Set SCTLR */
	mrc	p15, 0, r1, c1, c0, 0			@ Read SCTLR 
1c00000c:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
	bic	r1, r1, #0x10000000			@ Clear TEX bit
1c000010:	e3c11201 	bic	r1, r1, #268435456	; 0x10000000
	bic	r1, r1, #0x00002000			@ Clear Vectors bit 
1c000014:	e3c11a02 	bic	r1, r1, #8192	; 0x2000
	mcr	p15, 0, r1, c1, c0, 0			@ Write SCTLR 
1c000018:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
	/* Set NSACR */
	mrc	p15, 0, r1, c1, c1, 2			@ Read NSACR 
1c00001c:	ee111f51 	mrc	15, 0, r1, cr1, cr1, {2}
	ldr	r2, =NSACR_REG_VAL			
1c000020:	e59f20ec 	ldr	r2, [pc, #236]	; 1c000114 <c_environment_init+0x20>
	orr	r1, r1, r2				@ Mask r1 with r2
1c000024:	e1811002 	orr	r1, r1, r2
	mcr	p15, 0, r1, c1, c1, 2			@ Write NSACR 
1c000028:	ee011f51 	mcr	15, 0, r1, cr1, cr1, {2}
	/* Non-Route FIQs Monitor */
	mrc	p15, 0, r1, c1, c1, 0			@ Read SCR 
1c00002c:	ee111f11 	mrc	15, 0, r1, cr1, cr1, {0}
	bic  	r1, r1, #SCR_FIQ_BIT			@ Clear FIQ bit (disable route FIQs monitor)
1c000030:	e3c11004 	bic	r1, r1, #4
	mcr	p15, 0, r1, c1, c1, 0			@ Write SCR 
1c000034:	ee011f11 	mcr	15, 0, r1, cr1, cr1, {0}
	/* Set Auxiliary register reset value */
	mrc	p15, 0, r0, c1, c0, 1			@ Read ACTLR
1c000038:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
	ldr  	r0, =0x00				@ Clear registers
1c00003c:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c1, c0, 1			@ Write ACTLR
1c000040:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}

	/** Set monitor vector table (VBAR) */
	ldr	r0, =_monitor_vector_table		@ Read the Monitor Vector Table's Base Address
1c000044:	e59f00cc 	ldr	r0, [pc, #204]	; 1c000118 <c_environment_init+0x24>
	mcr	p15, 0, r0, c12, c0, 1			@ Write MVBAR
1c000048:	ee0c0f30 	mcr	15, 0, r0, cr12, cr0, {1}

1c00004c <__setup_stacks>:


	/** Setup Stacks for all CPU modes */
__setup_stacks:
	/* MONITOR mode */
	msr	cpsr_c,#(MONITOR_MODE | IRQ_BIT | FIQ_BIT)	@ Change CPSR to Monitor MODE and disable only IRQ interrupts
1c00004c:	e321f0d6 	msr	CPSR_c, #214	; 0xd6
	ldr	r1,=_monitor_stack				
1c000050:	e59f10c4 	ldr	r1, [pc, #196]	; 1c00011c <c_environment_init+0x28>
	add	r1, r1, r0, lsl #STACK_SIZE_SHIFT		
1c000054:	e0811600 	add	r1, r1, r0, lsl #12
	add	sp, r1, #STACK_SIZE				
1c000058:	e281da02 	add	sp, r1, #8192	; 0x2000

1c00005c <__init_vmemory>:
	

	/** Handling cache and MMU subsystems */
__init_vmemory:	

	bl    	mmu_disable
1c00005c:	eb000186 	bl	1c00067c <mmu_disable>
	bl		dCache_disable
1c000060:	eb0000fc 	bl	1c000458 <dCache_disable>
	bl		iCache_disable
1c000064:	eb000137 	bl	1c000548 <iCache_disable>
@	bl		cachel2_init
	bl		cachel2_disable
1c000068:	eb000bb7 	bl	1c002f4c <cachel2_disable>

	bl		mmu_tlb_invalidate
1c00006c:	eb000198 	bl	1c0006d4 <mmu_tlb_invalidate>
	bl		dCache_invalidate
1c000070:	eb000109 	bl	1c00049c <dCache_invalidate>
	bl		iCache_invalidate
1c000074:	eb00013b 	bl	1c000568 <iCache_invalidate>
	bl		cachel2_invalidate
1c000078:	eb000bc1 	bl	1c002f84 <cachel2_invalidate>

	/* Invalidate Branch Predictor arrays */
	mov 	r1,#0					
1c00007c:	e3a01000 	mov	r1, #0
	mcr	p15, 0, r1, c7, c5, 6			@ Invalidate BP
1c000080:	ee071fd5 	mcr	15, 0, r1, cr7, cr5, {6}

	ldr		r0, =page_table
1c000084:	e59f0094 	ldr	r0, [pc, #148]	; 1c000120 <c_environment_init+0x2c>
	bl		mmu_ttbr0_set
1c000088:	eb000181 	bl	1c000694 <mmu_ttbr0_set>

	ldr		r0, =0x55555555
1c00008c:	e59f0090 	ldr	r0, [pc, #144]	; 1c000124 <c_environment_init+0x30>
	bl 		mmu_set_domain_access
1c000090:	eb00018b 	bl	1c0006c4 <mmu_set_domain_access>

	mrc     p15, 0, r0, c1, c1, 0	
1c000094:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
	orr		r0, r0, #SCR_NS_BIT	
1c000098:	e3800001 	orr	r0, r0, #1
	mcr     p15, 0, r0, c1, c1, 0	
1c00009c:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}

	ldr		r0, =page_table
1c0000a0:	e59f0078 	ldr	r0, [pc, #120]	; 1c000120 <c_environment_init+0x2c>
	bl		mmu_ttbr0_set
1c0000a4:	eb00017a 	bl	1c000694 <mmu_ttbr0_set>

	ldr		r0, =0x55555555
1c0000a8:	e59f0074 	ldr	r0, [pc, #116]	; 1c000124 <c_environment_init+0x30>
	bl 		mmu_set_domain_access
1c0000ac:	eb000184 	bl	1c0006c4 <mmu_set_domain_access>

	bl		iCache_enable
1c0000b0:	eb00011c 	bl	1c000528 <iCache_enable>
	bl		dCache_enable
1c0000b4:	eb0000df 	bl	1c000438 <dCache_enable>
	bl		mmu_enable
1c0000b8:	eb000169 	bl	1c000664 <mmu_enable>

	mrc     p15, 0, r0, c1, c1, 0	
1c0000bc:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
	bic		r0, r0, #SCR_NS_BIT		
1c0000c0:	e3c00001 	bic	r0, r0, #1
	mcr     p15, 0, r0, c1, c1, 0	
1c0000c4:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}

	bl		iCache_enable
1c0000c8:	eb000116 	bl	1c000528 <iCache_enable>
	bl		cachel2_enable
1c0000cc:	eb000b90 	bl	1c002f14 <cachel2_enable>
	bl		dCache_enable
1c0000d0:	eb0000d8 	bl	1c000438 <dCache_enable>
	bl		mmu_enable
1c0000d4:	eb000162 	bl	1c000664 <mmu_enable>

1c0000d8 <__init_c_env>:
	/* FIX IT */
	

	/** Initializing C environment */
__init_c_env:
	bl	c_environment_init
1c0000d8:	eb000005 	bl	1c0000f4 <c_environment_init>

1c0000dc <__call_main>:
	/**  Call Main */
__call_main:
//.globl cpu_init
	//bl	cpu_init				@@@ Jump to Operating System 'c' entry function
.globl ltzvisor_main
	bl	ltzvisor_main				@ Jump to LTZVisor entry function
1c0000dc:	eb00058d 	bl	1c001718 <ltzvisor_main>
	/* This point should never be reached */
	b	.
1c0000e0:	eafffffe 	b	1c0000e0 <__call_main+0x4>

1c0000e4 <__stuck_loop>:
 * @param
 *
 * @retval 
 */
__stuck_loop:
	b	__stuck_loop
1c0000e4:	eafffffe 	b	1c0000e4 <__stuck_loop>

1c0000e8 <get_cpu_id>:
 */
.global get_cpu_id
.func get_cpu_id
  @ uint32_t get_cpu_id(void)
get_cpu_id:
	mrc	p15, 0, r0, c0, c0, 5
1c0000e8:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
	and	r0, r0, #0x03
1c0000ec:	e2000003 	and	r0, r0, #3
	bx	lr
1c0000f0:	e12fff1e 	bx	lr

1c0000f4 <c_environment_init>:
 * @retval 	
 */
.global c_environment_init
c_environment_init:
	/* bss initialization (zeros) */
	ldr	r1, =_SW_BSS_START
1c0000f4:	e59f102c 	ldr	r1, [pc, #44]	; 1c000128 <c_environment_init+0x34>
	ldr	r2, =_SW_BSS_END
1c0000f8:	e59f202c 	ldr	r2, [pc, #44]	; 1c00012c <c_environment_init+0x38>
	mov	r0, #0
1c0000fc:	e3a00000 	mov	r0, #0
2:
	cmp	r1, r2
1c000100:	e1510002 	cmp	r1, r2
	bgt	1f
1c000104:	ca000001 	bgt	1c000110 <c_environment_init+0x1c>
	str	r0,	[r1], #4
1c000108:	e4810004 	str	r0, [r1], #4
	b	2b
1c00010c:	eafffffb 	b	1c000100 <c_environment_init+0xc>
1:
	mov		pc, lr
1c000110:	e1a0f00e 	mov	pc, lr
	ldr	r2, =NSACR_REG_VAL			
1c000114:	00060c00 	.word	0x00060c00
	ldr	r0, =_monitor_vector_table		@ Read the Monitor Vector Table's Base Address
1c000118:	1c000200 	.word	0x1c000200
	ldr	r1,=_monitor_stack				
1c00011c:	1c037838 	.word	0x1c037838
	ldr		r0, =page_table
1c000120:	00004000 	.word	0x00004000
	ldr		r0, =0x55555555
1c000124:	55555555 	.word	0x55555555
	ldr	r1, =_SW_BSS_START
1c000128:	1c038000 	.word	0x1c038000
	ldr	r2, =_SW_BSS_END
1c00012c:	1c03a000 	.word	0x1c03a000

1c000130 <mon_swi_handler>:
 *
 * @param  
 *
 * @retval 
 */
void mon_swi_handler(void){
1c000130:	e92d581f 	push	{r0, r1, r2, r3, r4, fp, ip, lr}
1c000134:	e28db01c 	add	fp, sp, #28

	printk("LTZVisor: SWI Exception\n\r");
1c000138:	e3030220 	movw	r0, #12832	; 0x3220
1c00013c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c000140:	eb00046c 	bl	1c0012f8 <printk>
	/* FIXME */
	while(1);
1c000144:	eafffffe 	b	1c000144 <mon_swi_handler+0x14>

1c000148 <mon_abort_handler>:
 *
 * @param  
 *
 * @retval 
 */
void mon_abort_handler(void){
1c000148:	e92d4800 	push	{fp, lr}
1c00014c:	e28db004 	add	fp, sp, #4

	printk("LTZVisor: ABORT Exception\n\r");
1c000150:	e303023c 	movw	r0, #12860	; 0x323c
1c000154:	e3410c00 	movt	r0, #7168	; 0x1c00
1c000158:	eb000466 	bl	1c0012f8 <printk>
	/* FIXME */
	while(1);
1c00015c:	eafffffe 	b	1c00015c <mon_abort_handler+0x14>

1c000160 <mon_irq_handler>:
 *
 * @param  
 *
 * @retval 
 */
void mon_irq_handler(void){
1c000160:	e24ee004 	sub	lr, lr, #4
1c000164:	e92d581f 	push	{r0, r1, r2, r3, r4, fp, ip, lr}
1c000168:	e28db01c 	add	fp, sp, #28

	/** By design it is not supposed to come here */
	printk("LTZVisor: IRQ Exception\n\r");
1c00016c:	e3030258 	movw	r0, #12888	; 0x3258
1c000170:	e3410c00 	movt	r0, #7168	; 0x1c00
1c000174:	eb00045f 	bl	1c0012f8 <printk>
	/* FIXME */
	while(1);
1c000178:	eafffffe 	b	1c000178 <mon_irq_handler+0x18>

1c00017c <mon_prefetch_handler>:
 *
 * @param  
 *
 * @retval 
 */
void mon_prefetch_handler(void){
1c00017c:	e92d4800 	push	{fp, lr}
1c000180:	e28db004 	add	fp, sp, #4

	printk("LTZVisor: PREFETCH Exception\n\r");
1c000184:	e3030274 	movw	r0, #12916	; 0x3274
1c000188:	e3410c00 	movt	r0, #7168	; 0x1c00
1c00018c:	eb000459 	bl	1c0012f8 <printk>
	/* FIXME */
	while(1);
1c000190:	eafffffe 	b	1c000190 <mon_prefetch_handler+0x14>
	...

1c000200 <_monitor_vector_table>:
 */
.align 8
.global _monitor_vector_table
	/** Monitor Vector Table definition */
_monitor_vector_table:
	b	.				@ Not available on MON
1c000200:	eafffffe 	b	1c000200 <_monitor_vector_table>
	b	.				@ Not available on MON
1c000204:	eafffffe 	b	1c000204 <_monitor_vector_table+0x4>
	ldr	pc, __mon_smc_handler
1c000208:	e59ff010 	ldr	pc, [pc, #16]	; 1c000220 <__mon_smc_handler>
	ldr	pc, __mon_prefetch_handler
1c00020c:	e59ff010 	ldr	pc, [pc, #16]	; 1c000224 <__mon_prefetch_handler>
	ldr	pc, __mon_abort_handler
1c000210:	e59ff010 	ldr	pc, [pc, #16]	; 1c000228 <__mon_abort_handler>
	b	.				@ Reserved for HYP
1c000214:	eafffffe 	b	1c000214 <_monitor_vector_table+0x14>
	ldr	pc, __mon_irq_handler		@ Should never come here
1c000218:	e59ff00c 	ldr	pc, [pc, #12]	; 1c00022c <__mon_irq_handler>
	ldr	pc, __mon_fiq_handler
1c00021c:	e59ff00c 	ldr	pc, [pc, #12]	; 1c000230 <__mon_fiq_handler>

1c000220 <__mon_smc_handler>:
1c000220:	1c000234 	.word	0x1c000234

1c000224 <__mon_prefetch_handler>:
1c000224:	1c00017c 	.word	0x1c00017c

1c000228 <__mon_abort_handler>:
1c000228:	1c000148 	.word	0x1c000148

1c00022c <__mon_irq_handler>:
1c00022c:	1c000160 	.word	0x1c000160

1c000230 <__mon_fiq_handler>:
1c000230:	1c000248 	.word	0x1c000248

1c000234 <_mon_smc_handler>:
 * @retval	 
 */
.globl _mon_smc_handler
	/** Monitor - SMC handler */
_mon_smc_handler:
	cmn	r0, #0
1c000234:	e3700000 	cmn	r0, #0
	blt	board_smc
1c000238:	ba000039 	blt	1c000324 <board_smc>
	cmp 	r0, #LTZVISOR_SCHED_SYSCALL
1c00023c:	e37002ff 	cmn	r0, #-268435441	; 0xf000000f
	beq	_mon_scheduler
1c000240:	0a000042 	beq	1c000350 <_mon_scheduler>
	bx	lr
1c000244:	e12fff1e 	bx	lr

1c000248 <_mon_fiq_handler>:
 * @retval	 
 */
.globl _mon_fiq_handler
	/** Monitor - FIQ handler */
_mon_fiq_handler:
	sub	lr, lr, #4			@ Adjust LR
1c000248:	e24ee004 	sub	lr, lr, #4

	SCR_NS_CLEAR				@ Disable NS bit and route FIQs in mon
1c00024c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
1c000250:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
1c000254:	e3c00001 	bic	r0, r0, #1
1c000258:	e3c00004 	bic	r0, r0, #4
1c00025c:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}
1c000260:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)

	NSWORLD_CONTEXT_SAVE
1c000264:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
1c000268:	e59fe1c4 	ldr	lr, [pc, #452]	; 1c000434 <_mon_scheduler+0xe4>
1c00026c:	e28ee000 	add	lr, lr, #0
1c000270:	e8ae1fff 	stmia	lr!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
1c000274:	e1a0000e 	mov	r0, lr
1c000278:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
1c00027c:	e14f1000 	mrs	r1, SPSR
1c000280:	e8a04002 	stmia	r0!, {r1, lr}
1c000284:	f1020013 	cps	#19
1c000288:	e14f1000 	mrs	r1, SPSR
1c00028c:	e8a06002 	stmia	r0!, {r1, sp, lr}
1c000290:	f102001f 	cps	#31
1c000294:	e14f1000 	mrs	r1, SPSR
1c000298:	e8a06002 	stmia	r0!, {r1, sp, lr}
1c00029c:	f1020017 	cps	#23
1c0002a0:	e14f1000 	mrs	r1, SPSR
1c0002a4:	e8a06002 	stmia	r0!, {r1, sp, lr}
1c0002a8:	f102001b 	cps	#27
1c0002ac:	e14f1000 	mrs	r1, SPSR
1c0002b0:	e8a06002 	stmia	r0!, {r1, sp, lr}
1c0002b4:	f1020012 	cps	#18
1c0002b8:	e14f1000 	mrs	r1, SPSR
1c0002bc:	e8a06002 	stmia	r0!, {r1, sp, lr}
1c0002c0:	f1020016 	cps	#22

	mov r0, sp
1c0002c4:	e1a0000d 	mov	r0, sp

	cps #FIQ_MODE
1c0002c8:	f1020011 	cps	#17
	ldmfd    r0!, {r1, sp, lr}
1c0002cc:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr		spsr, r1
1c0002d0:	e169f001 	msr	SPSR_fc, r1
	ldmfd 	r0!, {r8-r12}
1c0002d4:	e8b01f00 	ldm	r0!, {r8, r9, sl, fp, ip}

	cps #IRQ_MODE
1c0002d8:	f1020012 	cps	#18
	ldmfd   r0!, {r1, sp, lr}
1c0002dc:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr	 	spsr, r1
1c0002e0:	e169f001 	msr	SPSR_fc, r1

	cps #UNDEFINED_MODE
1c0002e4:	f102001b 	cps	#27
	ldmfd   r0!, {r1, sp, lr}
1c0002e8:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr	 	spsr, r1
1c0002ec:	e169f001 	msr	SPSR_fc, r1

	cps #ABORT_MODE
1c0002f0:	f1020017 	cps	#23
	ldmfd   r0!, {r1, sp, lr}
1c0002f4:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr	 	spsr, r1
1c0002f8:	e169f001 	msr	SPSR_fc, r1

	cps #SYSTEM_MODE
1c0002fc:	f102001f 	cps	#31
	ldmfd   r0!, {r1, sp, lr}
1c000300:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr	 	spsr, r1
1c000304:	e169f001 	msr	SPSR_fc, r1

	cps #SUPERVISOR_MODE
1c000308:	f1020013 	cps	#19
	ldmfd   r0!, {r1, sp, lr}	
1c00030c:	e8b06002 	ldm	r0!, {r1, sp, lr}
	msr	 	spsr, r1
1c000310:	e169f001 	msr	SPSR_fc, r1

	cps #MONITOR_MODE
1c000314:	f1020016 	cps	#22
	mov sp, r0
1c000318:	e1a0d000 	mov	sp, r0
	pop {r0-r12}
1c00031c:	e8bd1fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}

	rfefd sp!
1c000320:	f8bd0a00 	rfeia	sp!

1c000324 <board_smc>:
 * @param
 *
 * @retval	 
 */
board_smc:
	call_c_function_arg board_handler
1c000324:	e92d5ffe 	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
1c000328:	e14f4000 	mrs	r4, SPSR
1c00032c:	e92d0010 	stmfd	sp!, {r4}
1c000330:	eb000793 	bl	1c002184 <board_handler>
	exception_return_arg
1c000334:	e8bd0002 	ldmfd	sp!, {r1}
1c000338:	e169f001 	msr	SPSR_fc, r1
1c00033c:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
1c000340:	e3a01000 	mov	r1, #0
1c000344:	f57ff04f 	dsb	sy
1c000348:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
1c00034c:	e8fd9ffe 	ldm	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^

1c000350 <_mon_scheduler>:
 * @retval	 
 */
.globl _mon_scheduler
_mon_scheduler:

	srsfd sp!, #MONITOR_MODE
1c000350:	f96d0516 	srsdb	sp!, #22
	push {r0-r12}
1c000354:	e92d1fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
	mov r0, sp
1c000358:	e1a0000d 	mov	r0, sp

	cps #SUPERVISOR_MODE
1c00035c:	f1020013 	cps	#19
	mrs	 r1, spsr
1c000360:	e14f1000 	mrs	r1, SPSR
	stmfd    r0!, {r1, sp, lr}
1c000364:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #SYSTEM_MODE
1c000368:	f102001f 	cps	#31
	mrs	 r1, spsr
1c00036c:	e14f1000 	mrs	r1, SPSR
	stmfd   r0!, {r1, sp, lr}
1c000370:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #ABORT_MODE
1c000374:	f1020017 	cps	#23
	mrs	 r1, spsr
1c000378:	e14f1000 	mrs	r1, SPSR
	stmfd    r0!, {r1, sp, lr}
1c00037c:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #UNDEFINED_MODE
1c000380:	f102001b 	cps	#27
	mrs	 r1, spsr
1c000384:	e14f1000 	mrs	r1, SPSR
	stmfd    r0!, {r1, sp, lr}
1c000388:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #IRQ_MODE
1c00038c:	f1020012 	cps	#18
	mrs	 r1, spsr
1c000390:	e14f1000 	mrs	r1, SPSR
	stmfd    r0!, {r1, sp, lr}
1c000394:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #FIQ_MODE
1c000398:	f1020011 	cps	#17
	stmfd r0!, {r8-r12}
1c00039c:	e9201f00 	stmdb	r0!, {r8, r9, sl, fp, ip}
	mrs	 r1, spsr
1c0003a0:	e14f1000 	mrs	r1, SPSR
	stmfd    r0!, {r1, sp, lr}
1c0003a4:	e9206002 	stmdb	r0!, {r1, sp, lr}

	cps #MONITOR_MODE
1c0003a8:	f1020016 	cps	#22
	mov sp, r0
1c0003ac:	e1a0d000 	mov	sp, r0

	NSWORLD_CONTEXT_RESTORE
1c0003b0:	e59fe07c 	ldr	lr, [pc, #124]	; 1c000434 <_mon_scheduler+0xe4>
1c0003b4:	e28ee000 	add	lr, lr, #0
1c0003b8:	e8be1fff 	ldm	lr!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
1c0003bc:	e92d0003 	push	{r0, r1}
1c0003c0:	e1a0000e 	mov	r0, lr
1c0003c4:	e8b04002 	ldm	r0!, {r1, lr}
1c0003c8:	e16ff001 	msr	SPSR_fsxc, r1
1c0003cc:	f1020013 	cps	#19
1c0003d0:	e8b06002 	ldm	r0!, {r1, sp, lr}
1c0003d4:	e16ff001 	msr	SPSR_fsxc, r1
1c0003d8:	f102001f 	cps	#31
1c0003dc:	e8b06002 	ldm	r0!, {r1, sp, lr}
1c0003e0:	e16ff001 	msr	SPSR_fsxc, r1
1c0003e4:	f1020017 	cps	#23
1c0003e8:	e8b06002 	ldm	r0!, {r1, sp, lr}
1c0003ec:	e16ff001 	msr	SPSR_fsxc, r1
1c0003f0:	f102001b 	cps	#27
1c0003f4:	e8b06002 	ldm	r0!, {r1, sp, lr}
1c0003f8:	e16ff001 	msr	SPSR_fsxc, r1
1c0003fc:	f1020012 	cps	#18
1c000400:	e8b06002 	ldm	r0!, {r1, sp, lr}
1c000404:	e16ff001 	msr	SPSR_fsxc, r1
1c000408:	f1020016 	cps	#22
1c00040c:	e8bd0003 	pop	{r0, r1}

	/* Set NS bit and go NS world */
	SCR_NS_SET
1c000410:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
1c000414:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
1c000418:	e3800001 	orr	r0, r0, #1
1c00041c:	e3800004 	orr	r0, r0, #4
1c000420:	ee010f11 	mcr	15, 0, r0, cr1, cr1, {0}
1c000424:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
	isb
1c000428:	f57ff06f 	isb	sy
	dsb	
1c00042c:	f57ff04f 	dsb	sy
	movs    pc, lr				@ Return from exception (MON -> NS_SVC)
1c000430:	e1b0f00e 	movs	pc, lr
	NSWORLD_CONTEXT_SAVE
1c000434:	1c03983c 	.word	0x1c03983c

1c000438 <dCache_enable>:
/***************** Data Cache enable (L1) *****************/

.global dCache_enable
.func dCache_enable
dCache_enable:
	push	{r0}
1c000438:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	dmb
1c00043c:	f57ff05f 	dmb	sy
	mrc	p15, 0, r0, c1, c0, 0
1c000440:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	orr 	r0, r0, #SCTLR_DCACHE_BIT
1c000444:	e3800004 	orr	r0, r0, #4
	mcr 	p15, 0, r0, c1, c0, 0
1c000448:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	dsb
1c00044c:	f57ff04f 	dsb	sy
	pop	{r0}
1c000450:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  	bx      lr
1c000454:	e12fff1e 	bx	lr

1c000458 <dCache_disable>:

/***************** Data Cache disable (L1) ****************/
.global dCache_disable
.func dCache_disable
dCache_disable:
	push	{r0}
1c000458:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	dmb
1c00045c:	f57ff05f 	dmb	sy
	mrc	p15, 0, r0, c1, c0, 0
1c000460:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic 	r0, r0, #SCTLR_DCACHE_BIT
1c000464:	e3c00004 	bic	r0, r0, #4
	mcr 	p15, 0, r0, c1, c0, 0
1c000468:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	dsb
1c00046c:	f57ff04f 	dsb	sy
	pop	{r0}
1c000470:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  	bx      lr
1c000474:	e12fff1e 	bx	lr

1c000478 <dCache_invalidate_setWay>:
	r3 - LEADING ZEROS of WAY
	r4 - Set
*/

dCache_invalidate_setWay:
	mov	r9, r2
1c000478:	e1a09002 	mov	r9, r2
2:
	// val = (cache level << 1) | (set << log2 LINE_LEN) |  (way << LEADING_ZEROS_OF WAY)
	orr	r11, r0, r9, lsl r3
1c00047c:	e180b319 	orr	fp, r0, r9, lsl r3
	orr	r11, r11, r4, lsl r1
1c000480:	e18bb114 	orr	fp, fp, r4, lsl r1
	//mcr 	p15, 0, r11, c7, c14, 2		@ DCCISW
	//mcr 	p15, 0, r11, c7, c10, 2		@ DCCSW
	mcr 	p15, 0, r11, c7, c6, 2      @ DCISWC
1c000484:	ee07bf56 	mcr	15, 0, fp, cr7, cr6, {2}
	subs	r9, r9, #1
1c000488:	e2599001 	subs	r9, r9, #1
	bge 	2b
1c00048c:	aafffffa 	bge	1c00047c <dCache_invalidate_setWay+0x4>
	subs	r4, r4, #1
1c000490:	e2544001 	subs	r4, r4, #1
	bge 	dCache_invalidate_setWay
1c000494:	aafffff7 	bge	1c000478 <dCache_invalidate_setWay>
	bx	lr
1c000498:	e12fff1e 	bx	lr

1c00049c <dCache_invalidate>:

.global dCache_invalidate
.func dCache_invalidate
dCache_invalidate:
	push	{r0-r12, lr}
1c00049c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	dmb
1c0004a0:	f57ff05f 	dmb	sy
	// Level 1
	ldr r0, =CACHE_LEVEL1_SET
1c0004a4:	e3a00000 	mov	r0, #0
	ldr	r1, =MAX_L1_LINE_LEN
1c0004a8:	e3a01005 	mov	r1, #5
	ldr	r2, =MAX_L1_CACHE_WAYS
1c0004ac:	e3a02003 	mov	r2, #3
	clz	r3, r2
1c0004b0:	e16f3f12 	clz	r3, r2
	ldr	r4, =MAX_L1_SETS
1c0004b4:	e3a040ff 	mov	r4, #255	; 0xff
	bl	dCache_invalidate_setWay
1c0004b8:	ebffffee 	bl	1c000478 <dCache_invalidate_setWay>

	mov r0, #0
1c0004bc:	e3a00000 	mov	r0, #0
	dsb
1c0004c0:	f57ff04f 	dsb	sy
	isb
1c0004c4:	f57ff06f 	isb	sy
	pop	{r0-r12, lr}
1c0004c8:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	bx	lr
1c0004cc:	e12fff1e 	bx	lr

1c0004d0 <dCache_clean_setWay>:
	r3 - LEADING ZEROS of WAY
	r4 - Set
*/

dCache_clean_setWay:
	mov	r9, r2
1c0004d0:	e1a09002 	mov	r9, r2
4:
	// val = (cache level << 1) | (set << log2 LINE_LEN) |  (way << LEADING_ZEROS_OF WAY)
	orr	r11, r0, r9, lsl r3
1c0004d4:	e180b319 	orr	fp, r0, r9, lsl r3
	orr	r11, r11, r4, lsl r1
1c0004d8:	e18bb114 	orr	fp, fp, r4, lsl r1
	mcr 	p15, 0, r11, c7, c14, 2		@ DCCISW
1c0004dc:	ee07bf5e 	mcr	15, 0, fp, cr7, cr14, {2}
	//mcr 	p15, 0, r11, c7, c10, 2		@ DCCSW
	//mcr 	p15, 0, r11, c7, c6, 2      @ DCISW
	subs	r9, r9, #1
1c0004e0:	e2599001 	subs	r9, r9, #1
	bge 	4b
1c0004e4:	aafffffa 	bge	1c0004d4 <dCache_clean_setWay+0x4>
	subs	r4, r4, #1
1c0004e8:	e2544001 	subs	r4, r4, #1
	bge 	dCache_clean_setWay
1c0004ec:	aafffff7 	bge	1c0004d0 <dCache_clean_setWay>
	bx	lr
1c0004f0:	e12fff1e 	bx	lr

1c0004f4 <dCache_clean>:

.global dCache_clean
.func dCache_clean
dCache_clean:
	push	{r0-r12, lr}
1c0004f4:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	dmb
1c0004f8:	f57ff05f 	dmb	sy
	// Level 1
	ldr r0, =CACHE_LEVEL1_SET
1c0004fc:	e3a00000 	mov	r0, #0
	ldr	r1, =MAX_L1_LINE_LEN
1c000500:	e3a01005 	mov	r1, #5
	ldr	r2, =MAX_L1_CACHE_WAYS
1c000504:	e3a02003 	mov	r2, #3
	clz	r3, r2
1c000508:	e16f3f12 	clz	r3, r2
	ldr	r4, =MAX_L1_SETS
1c00050c:	e3a040ff 	mov	r4, #255	; 0xff
	bl	dCache_clean_setWay
1c000510:	ebffffee 	bl	1c0004d0 <dCache_clean_setWay>

	mov r0, #0
1c000514:	e3a00000 	mov	r0, #0
	dsb
1c000518:	f57ff04f 	dsb	sy
	isb
1c00051c:	f57ff06f 	isb	sy
	pop	{r0-r12, lr}
1c000520:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	bx	lr
1c000524:	e12fff1e 	bx	lr

1c000528 <iCache_enable>:
/************* Instruction Cache enable (L1) *************/

.global iCache_enable
.func iCache_enable
iCache_enable:
	push	{r0}
1c000528:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	dmb
1c00052c:	f57ff05f 	dmb	sy
	mrc		p15, 0, r0, c1, c0, 0
1c000530:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	orr 	r0, r0, #SCTLR_ICACHE_BIT
1c000534:	e3800a01 	orr	r0, r0, #4096	; 0x1000
	mcr 	p15, 0, r0, c1, c0, 0
1c000538:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	isb
1c00053c:	f57ff06f 	isb	sy
	pop		{r0}
1c000540:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  	bx      lr
1c000544:	e12fff1e 	bx	lr

1c000548 <iCache_disable>:

/************* Instruction Cache disable (L1) ************/
.global iCache_disable
.func iCache_disable
iCache_disable:
	push	{r0}
1c000548:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	dmb
1c00054c:	f57ff05f 	dmb	sy
	mrc		p15, 0, r0, c1, c0, 0
1c000550:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic 	r0, r0, #SCTLR_ICACHE_BIT
1c000554:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
	mcr 	p15, 0, r0, c1, c0, 0
1c000558:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	isb
1c00055c:	f57ff06f 	isb	sy
	pop		{r0}
1c000560:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  	bx      lr
1c000564:	e12fff1e 	bx	lr

1c000568 <iCache_invalidate>:
/********** Instruction Cache invalidate (L1) ************/

.global iCache_invalidate
.func iCache_invalidate
iCache_invalidate:
	push	{r0}
1c000568:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	dmb
1c00056c:	f57ff05f 	dmb	sy
	mov		r0, #0
1c000570:	e3a00000 	mov	r0, #0
	mcr 	p15, 0, r0, c7, c5, 0		@ ICIALLU (invalidate all)
1c000574:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	isb
1c000578:	f57ff06f 	isb	sy
	pop		{r0}
1c00057c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  	bx      lr
1c000580:	e12fff1e 	bx	lr

1c000584 <cp15_restore>:
.global cp15_restore
.func cp15_restore
	@ void cp15_restore(struct cp15_regs * p_cp15_context);
cp15_restore:
	@ Move to NS
	scr_nsbit_set r2
1c000584:	ee112f11 	mrc	15, 0, r2, cr1, cr1, {0}
1c000588:	e3822001 	orr	r2, r2, #1
1c00058c:	ee012f11 	mcr	15, 0, r2, cr1, cr1, {0}
	@ restore c15 context
	restore_cp15_context
1c000590:	e4902004 	ldr	r2, [r0], #4
1c000594:	ee402f10 	mcr	15, 2, r2, cr0, cr0, {0}
1c000598:	e4902004 	ldr	r2, [r0], #4
1c00059c:	ee012f10 	mcr	15, 0, r2, cr1, cr0, {0}
1c0005a0:	e4902004 	ldr	r2, [r0], #4
1c0005a4:	ee012f30 	mcr	15, 0, r2, cr1, cr0, {1}
1c0005a8:	e4902004 	ldr	r2, [r0], #4
1c0005ac:	ee022f10 	mcr	15, 0, r2, cr2, cr0, {0}
1c0005b0:	e4902004 	ldr	r2, [r0], #4
1c0005b4:	ee022f30 	mcr	15, 0, r2, cr2, cr0, {1}
1c0005b8:	e4902004 	ldr	r2, [r0], #4
1c0005bc:	ee022f50 	mcr	15, 0, r2, cr2, cr0, {2}
1c0005c0:	e4902004 	ldr	r2, [r0], #4
1c0005c4:	ee032f10 	mcr	15, 0, r2, cr3, cr0, {0}
1c0005c8:	e4902004 	ldr	r2, [r0], #4
1c0005cc:	ee052f10 	mcr	15, 0, r2, cr5, cr0, {0}
1c0005d0:	e4902004 	ldr	r2, [r0], #4
1c0005d4:	ee052f30 	mcr	15, 0, r2, cr5, cr0, {1}
1c0005d8:	e4902004 	ldr	r2, [r0], #4
1c0005dc:	ee062f10 	mcr	15, 0, r2, cr6, cr0, {0}
1c0005e0:	e4902004 	ldr	r2, [r0], #4
1c0005e4:	ee062f50 	mcr	15, 0, r2, cr6, cr0, {2}
1c0005e8:	e4902004 	ldr	r2, [r0], #4
1c0005ec:	ee072f14 	mcr	15, 0, r2, cr7, cr4, {0}
1c0005f0:	e4902004 	ldr	r2, [r0], #4
1c0005f4:	ee0a2f12 	mcr	15, 0, r2, cr10, cr2, {0}
1c0005f8:	e4902004 	ldr	r2, [r0], #4
1c0005fc:	ee0a2f32 	mcr	15, 0, r2, cr10, cr2, {1}
1c000600:	e4902004 	ldr	r2, [r0], #4
1c000604:	ee0c2f10 	mcr	15, 0, r2, cr12, cr0, {0}
1c000608:	e4902004 	ldr	r2, [r0], #4
1c00060c:	ee0d2f10 	mcr	15, 0, r2, cr13, cr0, {0}
1c000610:	e4902004 	ldr	r2, [r0], #4
1c000614:	ee0d2f30 	mcr	15, 0, r2, cr13, cr0, {1}
1c000618:	e4902004 	ldr	r2, [r0], #4
1c00061c:	ee0d2f50 	mcr	15, 0, r2, cr13, cr0, {2}
1c000620:	e4902004 	ldr	r2, [r0], #4
1c000624:	ee0d2f70 	mcr	15, 0, r2, cr13, cr0, {3}
1c000628:	e4902004 	ldr	r2, [r0], #4
1c00062c:	ee0d2f90 	mcr	15, 0, r2, cr13, cr0, {4}
	@ Move back to secure
	scr_nsbit_clear r2
1c000630:	ee112f11 	mrc	15, 0, r2, cr1, cr1, {0}
1c000634:	e3c22001 	bic	r2, r2, #1
1c000638:	ee012f11 	mcr	15, 0, r2, cr1, cr1, {0}
	bx	lr
1c00063c:	e12fff1e 	bx	lr

1c000640 <set_guest_context>:
 *
 * @param	addr = context pointer address   
 *
 * @retval 
 */
void set_guest_context(uint32_t addr) {
1c000640:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c000644:	e28db000 	add	fp, sp, #0
1c000648:	e24dd00c 	sub	sp, sp, #12
1c00064c:	e50b0008 	str	r0, [fp, #-8]
	/** Software Thread ID - TPIDRPRW */
	asm volatile("mcr p15, 0, r0, c13, c0, 4\n\t");
1c000650:	ee0d0f90 	mcr	15, 0, r0, cr13, cr0, {4}
}
1c000654:	e320f000 	nop	{0}
1c000658:	e24bd000 	sub	sp, fp, #0
1c00065c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c000660:	e12fff1e 	bx	lr

1c000664 <mmu_enable>:
/*********************** Enable MMU ***********************/
.globl mmu_enable
.func mmu_enable
@ void mmu_enable(void);
mmu_enable:
	mrc     p15, 0, r1, c1, c0, 0		@ Read SCTLR
1c000664:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
	orr     r1, r1, #SCTLR_M_BIT       	@ Set M bit (MMU)
1c000668:	e3811001 	orr	r1, r1, #1
    @ orr    	r1, r1, #SCTLR_U_BIT        @ Set U bit (Unaligned data access)
    @ orr    	r1, r1, #SCTLR_XP_BIT       @ Set XP bit (Extended page tables)
	mcr     p15, 0, r1, c1, c0, 0  		@ Write SCTLR
1c00066c:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
	dsb
1c000670:	f57ff04f 	dsb	sy
	isb
1c000674:	f57ff06f 	isb	sy
	bx	lr
1c000678:	e12fff1e 	bx	lr

1c00067c <mmu_disable>:
/*********************** Disable MMU **********************/
.globl mmu_disable
.func mmu_disable
@ void mmu_disable(void);
mmu_disable:
	mrc     p15, 0, r1, c1, c0, 0		@ Read SCTLR
1c00067c:	ee111f10 	mrc	15, 0, r1, cr1, cr0, {0}
	bic     r1, r1, #SCTLR_M_BIT       	@ Clear M bit (MMU)
1c000680:	e3c11001 	bic	r1, r1, #1
//    bic    	r1, r1, #SCTLR_U_BIT         @ Clear U bit (Unaligned data access)
//    bic    	r1, r1, #SCTLR_XP_BIT       @ Clear XP bit (Extended page tables)
	mcr     p15, 0, r1, c1, c0, 0  		@ Write SCTLR
1c000684:	ee011f10 	mcr	15, 0, r1, cr1, cr0, {0}
	dsb
1c000688:	f57ff04f 	dsb	sy
	isb
1c00068c:	f57ff06f 	isb	sy
	bx	lr
1c000690:	e12fff1e 	bx	lr

1c000694 <mmu_ttbr0_set>:
.globl mmu_ttbr0_set
.func mmu_ttbr0_set
@ void mmu_ttbr0_set(uint32_t ttbr0_val);
@ r0 - ttbr0_val
mmu_ttbr0_set:
	mcr    p15, 0, r0, c2, c0, 0	@ Write TTBR0
1c000694:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
	dsb
1c000698:	f57ff04f 	dsb	sy
	isb
1c00069c:	f57ff06f 	isb	sy
	bx	lr
1c0006a0:	e12fff1e 	bx	lr

1c0006a4 <mmu_ttbr1_set>:
.globl mmu_ttbr1_set
.func mmu_ttbr1_set
@ void mmu_ttbr1_set(uint32_t ttbr1_val);
@ r1 - ttbr1_val
mmu_ttbr1_set:
	mcr    p15, 0, r0, c2, c0, 1	@ Write TTBR1
1c0006a4:	ee020f30 	mcr	15, 0, r0, cr2, cr0, {1}
	dsb
1c0006a8:	f57ff04f 	dsb	sy
	isb
1c0006ac:	f57ff06f 	isb	sy
	bx	lr
1c0006b0:	e12fff1e 	bx	lr

1c0006b4 <mmu_ttbcr_set>:


.global mmu_ttbcr_set
.func mmu_ttbcr_set
mmu_ttbcr_set:
	mcr    p15, 0, r0, c2, c0, 2	@ Write TTBCR
1c0006b4:	ee020f50 	mcr	15, 0, r0, cr2, cr0, {2}
	dsb
1c0006b8:	f57ff04f 	dsb	sy
	isb
1c0006bc:	f57ff06f 	isb	sy
	bx	lr
1c0006c0:	e12fff1e 	bx	lr

1c0006c4 <mmu_set_domain_access>:
.globl mmu_set_domain_access
.func mmu_set_domain_access
@ void mmu_set_domain_access(uint32_t domain_access);
@ r0 - access_domain
mmu_set_domain_access:
	mcr    p15, 0, r0, c3, c0, 0	@ Write DACR
1c0006c4:	ee030f10 	mcr	15, 0, r0, cr3, cr0, {0}
    	dsb
1c0006c8:	f57ff04f 	dsb	sy
	isb
1c0006cc:	f57ff06f 	isb	sy
	bx	lr
1c0006d0:	e12fff1e 	bx	lr

1c0006d4 <mmu_tlb_invalidate>:

.globl mmu_tlb_invalidate
.func mmu_tlb_invalidate
@ void mmu_tlb_invalidate(void);
mmu_tlb_invalidate:
	mov    r0, #0
1c0006d4:	e3a00000 	mov	r0, #0
	mcr    p15, 0, r0, c8, c7, 0	@ TLBIALL
1c0006d8:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    dsb
1c0006dc:	f57ff04f 	dsb	sy
	isb
1c0006e0:	f57ff06f 	isb	sy
	bx	lr
1c0006e4:	e12fff1e 	bx	lr

1c0006e8 <mmu_set_context>:
.globl mmu_set_context
.func mmu_set_context
@ void mmu_set_context(uint32_t context);
@ r0 - context id;
mmu_set_context:
	mcr    p15, 0, r0, c13, c0, 1	@ CONTEXTDIR
1c0006e8:	ee0d0f30 	mcr	15, 0, r0, cr13, cr0, {1}
    dsb
1c0006ec:	f57ff04f 	dsb	sy
	isb
1c0006f0:	f57ff06f 	isb	sy
	bx	lr
1c0006f4:	e12fff1e 	bx	lr

1c0006f8 <mmu_va_to_pa>:
.globl mmu_va_to_pa
.func mmu_va_to_pa
@ uint32_t mmu_va_to_pa(uint32_t virt_addr);
@ r0 -  virt_addr
mmu_va_to_pa:
	mcr p15, 0, r0, c7, c8, 3
1c0006f8:	ee070f78 	mcr	15, 0, r0, cr7, cr8, {3}
	isb
1c0006fc:	f57ff06f 	isb	sy
	mrc p15, 0, r0, c7, c4, 0
1c000700:	ee170f14 	mrc	15, 0, r0, cr7, cr4, {0}
	isb
1c000704:	f57ff06f 	isb	sy
	dsb
1c000708:	f57ff04f 	dsb	sy
	bx	lr
1c00070c:	e12fff1e 	bx	lr

1c000710 <mmu_flush_tlb_asid>:
.globl mmu_flush_tlb_asid
.func mmu_flush_tlb_asid
@ void mmu_flush_tlb_asid(uint32_t asid);
@ r0 -  asid
mmu_flush_tlb_asid:
	mcr p15, 0, r0, c8, c7, 2
1c000710:	ee080f57 	mcr	15, 0, r0, cr8, cr7, {2}
	isb
1c000714:	f57ff06f 	isb	sy
	dsb
1c000718:	f57ff04f 	dsb	sy
	bx	lr
1c00071c:	e12fff1e 	bx	lr

1c000720 <mmu_flush_tlb_mva>:
.globl mmu_flush_tlb_mva
.func mmu_flush_tlb_mva
@ void mmu_flush_tlb_mva(uint32_t mva);
@ r0 -  virt_addr
mmu_flush_tlb_mva:
	mcr p15, 0, r0, c8, c7, 3
1c000720:	ee080f77 	mcr	15, 0, r0, cr8, cr7, {3}
	isb
1c000724:	f57ff06f 	isb	sy
	dsb
1c000728:	f57ff04f 	dsb	sy
	bx	lr
1c00072c:	e12fff1e 	bx	lr

1c000730 <mmu_flush_tlb>:

.globl mmu_flush_tlb
.func mmu_flush_tlb
@ void mmu_flush_tlb();
mmu_flush_tlb:
	mcr p15, 0, r0, c8, c7, 0
1c000730:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	isb
1c000734:	f57ff06f 	isb	sy
	dsb
1c000738:	f57ff04f 	dsb	sy
	bx	lr
1c00073c:	e12fff1e 	bx	lr

1c000740 <memcpy>:
 *		count = number of bytes to copy
 *
 * @retval  destination is returned
 */
void * memcpy(void * dst, const void * src, uint32_t count)
{
1c000740:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c000744:	e28db000 	add	fp, sp, #0
1c000748:	e24dd024 	sub	sp, sp, #36	; 0x24
1c00074c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
1c000750:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
1c000754:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
	int32_t i;
	char_t *dst_tmp = dst;
1c000758:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c00075c:	e50b300c 	str	r3, [fp, #-12]
	const char_t *src_tmp = src;
1c000760:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c000764:	e50b3010 	str	r3, [fp, #-16]

	if (!((uint32_t)src & 0x3) && !((uint32_t)dst & 0x3)){
1c000768:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c00076c:	e2033003 	and	r3, r3, #3
1c000770:	e3530000 	cmp	r3, #0
1c000774:	1a000038 	bne	1c00085c <memcpy+0x11c>
1c000778:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c00077c:	e2033003 	and	r3, r3, #3
1c000780:	e3530000 	cmp	r3, #0
1c000784:	1a000034 	bne	1c00085c <memcpy+0x11c>
		/** Word aligned - safe word copies */
		for (i=0; i < count; i+=4){
1c000788:	e3a03000 	mov	r3, #0
1c00078c:	e50b3008 	str	r3, [fp, #-8]
1c000790:	ea000013 	b	1c0007e4 <memcpy+0xa4>
			if (i + 3 > count - 1)
1c000794:	e51b3008 	ldr	r3, [fp, #-8]
1c000798:	e2833003 	add	r3, r3, #3
1c00079c:	e1a02003 	mov	r2, r3
1c0007a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c0007a4:	e2433001 	sub	r3, r3, #1
1c0007a8:	e1520003 	cmp	r2, r3
1c0007ac:	8a000011 	bhi	1c0007f8 <memcpy+0xb8>
				break; /* Don't copy too much */
			*(uint32_t *)dst_tmp = *(uint32_t *)src_tmp;
1c0007b0:	e51b3010 	ldr	r3, [fp, #-16]
1c0007b4:	e5932000 	ldr	r2, [r3]
1c0007b8:	e51b300c 	ldr	r3, [fp, #-12]
1c0007bc:	e5832000 	str	r2, [r3]
			dst_tmp += 4;
1c0007c0:	e51b300c 	ldr	r3, [fp, #-12]
1c0007c4:	e2833004 	add	r3, r3, #4
1c0007c8:	e50b300c 	str	r3, [fp, #-12]
			src_tmp += 4;
1c0007cc:	e51b3010 	ldr	r3, [fp, #-16]
1c0007d0:	e2833004 	add	r3, r3, #4
1c0007d4:	e50b3010 	str	r3, [fp, #-16]
		for (i=0; i < count; i+=4){
1c0007d8:	e51b3008 	ldr	r3, [fp, #-8]
1c0007dc:	e2833004 	add	r3, r3, #4
1c0007e0:	e50b3008 	str	r3, [fp, #-8]
1c0007e4:	e51b2008 	ldr	r2, [fp, #-8]
1c0007e8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c0007ec:	e1520003 	cmp	r2, r3
1c0007f0:	3affffe7 	bcc	1c000794 <memcpy+0x54>
1c0007f4:	ea000000 	b	1c0007fc <memcpy+0xbc>
				break; /* Don't copy too much */
1c0007f8:	e320f000 	nop	{0}
		}
		if (i <= count - 1){
1c0007fc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c000800:	e2432001 	sub	r2, r3, #1
1c000804:	e51b3008 	ldr	r3, [fp, #-8]
1c000808:	e1520003 	cmp	r2, r3
1c00080c:	3a000024 	bcc	1c0008a4 <memcpy+0x164>
			for (; i < count; i++){
1c000810:	ea00000c 	b	1c000848 <memcpy+0x108>
				*dst_tmp = *src_tmp;
1c000814:	e51b3010 	ldr	r3, [fp, #-16]
1c000818:	e5d32000 	ldrb	r2, [r3]
1c00081c:	e51b300c 	ldr	r3, [fp, #-12]
1c000820:	e5c32000 	strb	r2, [r3]
				dst_tmp++;
1c000824:	e51b300c 	ldr	r3, [fp, #-12]
1c000828:	e2833001 	add	r3, r3, #1
1c00082c:	e50b300c 	str	r3, [fp, #-12]
				src_tmp++;
1c000830:	e51b3010 	ldr	r3, [fp, #-16]
1c000834:	e2833001 	add	r3, r3, #1
1c000838:	e50b3010 	str	r3, [fp, #-16]
			for (; i < count; i++){
1c00083c:	e51b3008 	ldr	r3, [fp, #-8]
1c000840:	e2833001 	add	r3, r3, #1
1c000844:	e50b3008 	str	r3, [fp, #-8]
1c000848:	e51b2008 	ldr	r2, [fp, #-8]
1c00084c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c000850:	e1520003 	cmp	r2, r3
1c000854:	3affffee 	bcc	1c000814 <memcpy+0xd4>
		if (i <= count - 1){
1c000858:	ea000011 	b	1c0008a4 <memcpy+0x164>
			}
		}
	}
	else{
		/* Generic version */
		for (i=0; i < count; i++)
1c00085c:	e3a03000 	mov	r3, #0
1c000860:	e50b3008 	str	r3, [fp, #-8]
1c000864:	ea00000a 	b	1c000894 <memcpy+0x154>
			dst_tmp[i] = src_tmp[i];
1c000868:	e51b3008 	ldr	r3, [fp, #-8]
1c00086c:	e51b200c 	ldr	r2, [fp, #-12]
1c000870:	e0823003 	add	r3, r2, r3
1c000874:	e51b2008 	ldr	r2, [fp, #-8]
1c000878:	e51b1010 	ldr	r1, [fp, #-16]
1c00087c:	e0812002 	add	r2, r1, r2
1c000880:	e5d22000 	ldrb	r2, [r2]
1c000884:	e5c32000 	strb	r2, [r3]
		for (i=0; i < count; i++)
1c000888:	e51b3008 	ldr	r3, [fp, #-8]
1c00088c:	e2833001 	add	r3, r3, #1
1c000890:	e50b3008 	str	r3, [fp, #-8]
1c000894:	e51b2008 	ldr	r2, [fp, #-8]
1c000898:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c00089c:	e1520003 	cmp	r2, r3
1c0008a0:	3afffff0 	bcc	1c000868 <memcpy+0x128>
	}
	return dst;
1c0008a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
1c0008a8:	e1a00003 	mov	r0, r3
1c0008ac:	e24bd000 	sub	sp, fp, #0
1c0008b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0008b4:	e12fff1e 	bx	lr

1c0008b8 <memset>:
 *		count = number of bytes to be set
 *
 * @retval  pointer to the block of memory is returned
 */
void *memset(void * dest, uint32_t c, uint32_t count)
{
1c0008b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0008bc:	e28db000 	add	fp, sp, #0
1c0008c0:	e24dd01c 	sub	sp, sp, #28
1c0008c4:	e50b0010 	str	r0, [fp, #-16]
1c0008c8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
1c0008cc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	/** Standard bytewise memset */
	char_t* d;
	d = (char_t*) dest;
1c0008d0:	e51b3010 	ldr	r3, [fp, #-16]
1c0008d4:	e50b3008 	str	r3, [fp, #-8]

	while(count--){
1c0008d8:	ea000006 	b	1c0008f8 <memset+0x40>
		*d = c;
1c0008dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0008e0:	e6ef2073 	uxtb	r2, r3
1c0008e4:	e51b3008 	ldr	r3, [fp, #-8]
1c0008e8:	e5c32000 	strb	r2, [r3]
		d++;
1c0008ec:	e51b3008 	ldr	r3, [fp, #-8]
1c0008f0:	e2833001 	add	r3, r3, #1
1c0008f4:	e50b3008 	str	r3, [fp, #-8]
	while(count--){
1c0008f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c0008fc:	e2432001 	sub	r2, r3, #1
1c000900:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
1c000904:	e3530000 	cmp	r3, #0
1c000908:	1afffff3 	bne	1c0008dc <memset+0x24>
	}

	return dest;
1c00090c:	e51b3010 	ldr	r3, [fp, #-16]
}
1c000910:	e1a00003 	mov	r0, r3
1c000914:	e24bd000 	sub	sp, fp, #0
1c000918:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c00091c:	e12fff1e 	bx	lr

1c000920 <strcat>:
 *		src = C string to be appended
 *
 * @retval  destination is returned
 */
char_t * strcat(char_t *dest, cchar_t *src)
{
1c000920:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c000924:	e28db000 	add	fp, sp, #0
1c000928:	e24dd014 	sub	sp, sp, #20
1c00092c:	e50b0010 	str	r0, [fp, #-16]
1c000930:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	char_t *save = dest;
1c000934:	e51b3010 	ldr	r3, [fp, #-16]
1c000938:	e50b3008 	str	r3, [fp, #-8]

	for (; *dest; ++dest) ;
1c00093c:	ea000002 	b	1c00094c <strcat+0x2c>
1c000940:	e51b3010 	ldr	r3, [fp, #-16]
1c000944:	e2833001 	add	r3, r3, #1
1c000948:	e50b3010 	str	r3, [fp, #-16]
1c00094c:	e51b3010 	ldr	r3, [fp, #-16]
1c000950:	e5d33000 	ldrb	r3, [r3]
1c000954:	e3530000 	cmp	r3, #0
1c000958:	1afffff8 	bne	1c000940 <strcat+0x20>
	while ((*dest++ = *src++) != 0) ;
1c00095c:	e320f000 	nop	{0}
1c000960:	e51b3010 	ldr	r3, [fp, #-16]
1c000964:	e2832001 	add	r2, r3, #1
1c000968:	e50b2010 	str	r2, [fp, #-16]
1c00096c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c000970:	e2821001 	add	r1, r2, #1
1c000974:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
1c000978:	e5d22000 	ldrb	r2, [r2]
1c00097c:	e5c32000 	strb	r2, [r3]
1c000980:	e5d33000 	ldrb	r3, [r3]
1c000984:	e3530000 	cmp	r3, #0
1c000988:	1afffff4 	bne	1c000960 <strcat+0x40>

	return (save);
1c00098c:	e51b3008 	ldr	r3, [fp, #-8]
}
1c000990:	e1a00003 	mov	r0, r3
1c000994:	e24bd000 	sub	sp, fp, #0
1c000998:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c00099c:	e12fff1e 	bx	lr

1c0009a0 <strlen>:
 *
 * @param	s = C string
 *
 * @retval  The length of string
 */
uint32_t strlen(char_t * s){
1c0009a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0009a4:	e28db000 	add	fp, sp, #0
1c0009a8:	e24dd014 	sub	sp, sp, #20
1c0009ac:	e50b0010 	str	r0, [fp, #-16]

	char_t *sc;
	for (sc = s; *sc != '\0'; ++sc){
1c0009b0:	e51b3010 	ldr	r3, [fp, #-16]
1c0009b4:	e50b3008 	str	r3, [fp, #-8]
1c0009b8:	ea000002 	b	1c0009c8 <strlen+0x28>
1c0009bc:	e51b3008 	ldr	r3, [fp, #-8]
1c0009c0:	e2833001 	add	r3, r3, #1
1c0009c4:	e50b3008 	str	r3, [fp, #-8]
1c0009c8:	e51b3008 	ldr	r3, [fp, #-8]
1c0009cc:	e5d33000 	ldrb	r3, [r3]
1c0009d0:	e3530000 	cmp	r3, #0
1c0009d4:	1afffff8 	bne	1c0009bc <strlen+0x1c>
		/* Do nothing */
	}
	return sc - s;
1c0009d8:	e51b2008 	ldr	r2, [fp, #-8]
1c0009dc:	e51b3010 	ldr	r3, [fp, #-16]
1c0009e0:	e0423003 	sub	r3, r2, r3
}
1c0009e4:	e1a00003 	mov	r0, r3
1c0009e8:	e24bd000 	sub	sp, fp, #0
1c0009ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0009f0:	e12fff1e 	bx	lr

1c0009f4 <strnlen>:
 * @param	S = C string
 *		n = lsize
 *
 * @retval  The length of string
 */
uint32_t strnlen(char_t * s, size_t n){
1c0009f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0009f8:	e28db000 	add	fp, sp, #0
1c0009fc:	e24dd014 	sub	sp, sp, #20
1c000a00:	e50b0010 	str	r0, [fp, #-16]
1c000a04:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	char_t *str;

	for(str = s; *str != '\0' && n-- ; ++str){
1c000a08:	e51b3010 	ldr	r3, [fp, #-16]
1c000a0c:	e50b3008 	str	r3, [fp, #-8]
1c000a10:	ea000002 	b	1c000a20 <strnlen+0x2c>
1c000a14:	e51b3008 	ldr	r3, [fp, #-8]
1c000a18:	e2833001 	add	r3, r3, #1
1c000a1c:	e50b3008 	str	r3, [fp, #-8]
1c000a20:	e51b3008 	ldr	r3, [fp, #-8]
1c000a24:	e5d33000 	ldrb	r3, [r3]
1c000a28:	e3530000 	cmp	r3, #0
1c000a2c:	0a000004 	beq	1c000a44 <strnlen+0x50>
1c000a30:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c000a34:	e2432001 	sub	r2, r3, #1
1c000a38:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
1c000a3c:	e3530000 	cmp	r3, #0
1c000a40:	1afffff3 	bne	1c000a14 <strnlen+0x20>
		/* Do nothing */
	}
	return str-s;
1c000a44:	e51b2008 	ldr	r2, [fp, #-8]
1c000a48:	e51b3010 	ldr	r3, [fp, #-16]
1c000a4c:	e0423003 	sub	r3, r2, r3
}
1c000a50:	e1a00003 	mov	r0, r3
1c000a54:	e24bd000 	sub	sp, fp, #0
1c000a58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c000a5c:	e12fff1e 	bx	lr

1c000a60 <strcpy>:
 *		src = C string to be copied
 *
 * @retval  destination is returned
 */
char_t * strcpy(char_t * dest, char_t * src)
{
1c000a60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c000a64:	e28db000 	add	fp, sp, #0
1c000a68:	e24dd014 	sub	sp, sp, #20
1c000a6c:	e50b0010 	str	r0, [fp, #-16]
1c000a70:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
	char_t *tmp = dest;
1c000a74:	e51b3010 	ldr	r3, [fp, #-16]
1c000a78:	e50b3008 	str	r3, [fp, #-8]

	while ((*dest++ = *src++) != '\0'){
1c000a7c:	e320f000 	nop	{0}
1c000a80:	e51b3010 	ldr	r3, [fp, #-16]
1c000a84:	e2832001 	add	r2, r3, #1
1c000a88:	e50b2010 	str	r2, [fp, #-16]
1c000a8c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c000a90:	e2821001 	add	r1, r2, #1
1c000a94:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
1c000a98:	e5d22000 	ldrb	r2, [r2]
1c000a9c:	e5c32000 	strb	r2, [r3]
1c000aa0:	e5d33000 	ldrb	r3, [r3]
1c000aa4:	e3530000 	cmp	r3, #0
1c000aa8:	1afffff4 	bne	1c000a80 <strcpy+0x20>
		/* Do nothing */
	}
	return tmp;
1c000aac:	e51b3008 	ldr	r3, [fp, #-8]
}
1c000ab0:	e1a00003 	mov	r0, r3
1c000ab4:	e24bd000 	sub	sp, fp, #0
1c000ab8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c000abc:	e12fff1e 	bx	lr

1c000ac0 <vsprintk>:
 * (#) $id: printk.c 01-09-2015 s_pinto & j_pereira $
 * (#) $id: printk.c 18-09-2017 s_pinto (modified)$
*/
#include <printk.h>

uint32_t vsprintk(char *buf, const char *fmt, va_list args){
1c000ac0:	e92d4800 	push	{fp, lr}
1c000ac4:	e28db004 	add	fp, sp, #4
1c000ac8:	e24dd088 	sub	sp, sp, #136	; 0x88
1c000acc:	e50b0080 	str	r0, [fp, #-128]	; 0xffffff80
1c000ad0:	e50b1084 	str	r1, [fp, #-132]	; 0xffffff7c
1c000ad4:	e50b2088 	str	r2, [fp, #-136]	; 0xffffff78

	char *str;
	str = buf;
1c000ad8:	e51b3080 	ldr	r3, [fp, #-128]	; 0xffffff80
1c000adc:	e50b3008 	str	r3, [fp, #-8]
	uint32_t len = strnlen(buf,PRINT_TEXT_LEN);
1c000ae0:	e3a01c01 	mov	r1, #256	; 0x100
1c000ae4:	e51b0080 	ldr	r0, [fp, #-128]	; 0xffffff80
1c000ae8:	ebffffc1 	bl	1c0009f4 <strnlen>
1c000aec:	e50b000c 	str	r0, [fp, #-12]
	for(; *fmt ; ++fmt){
1c000af0:	ea0001f2 	b	1c0012c0 <vsprintk+0x800>
		if((*fmt != '%') && (*fmt != '\n') && (*fmt != '\t')){
1c000af4:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000af8:	e5d33000 	ldrb	r3, [r3]
1c000afc:	e3530025 	cmp	r3, #37	; 0x25
1c000b00:	0a00000e 	beq	1c000b40 <vsprintk+0x80>
1c000b04:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b08:	e5d33000 	ldrb	r3, [r3]
1c000b0c:	e353000a 	cmp	r3, #10
1c000b10:	0a00000a 	beq	1c000b40 <vsprintk+0x80>
1c000b14:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b18:	e5d33000 	ldrb	r3, [r3]
1c000b1c:	e3530009 	cmp	r3, #9
1c000b20:	0a000006 	beq	1c000b40 <vsprintk+0x80>
			*str++ = *fmt;
1c000b24:	e51b3008 	ldr	r3, [fp, #-8]
1c000b28:	e2832001 	add	r2, r3, #1
1c000b2c:	e50b2008 	str	r2, [fp, #-8]
1c000b30:	e51b2084 	ldr	r2, [fp, #-132]	; 0xffffff7c
1c000b34:	e5d22000 	ldrb	r2, [r2]
1c000b38:	e5c32000 	strb	r2, [r3]
			continue;
1c000b3c:	ea0001dc 	b	1c0012b4 <vsprintk+0x7f4>
		}

		if(*fmt == '%'){
1c000b40:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b44:	e5d33000 	ldrb	r3, [r3]
1c000b48:	e3530025 	cmp	r3, #37	; 0x25
1c000b4c:	1a0001c0 	bne	1c001254 <vsprintk+0x794>
			/* skip % */
			++fmt;
1c000b50:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b54:	e2833001 	add	r3, r3, #1
1c000b58:	e50b3084 	str	r3, [fp, #-132]	; 0xffffff7c
			uint32_t is_unsigned = 0;
1c000b5c:	e3a03000 	mov	r3, #0
1c000b60:	e50b3010 	str	r3, [fp, #-16]
			uint32_t zero_padding = 1;
1c000b64:	e3a03001 	mov	r3, #1
1c000b68:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

			if(*fmt == '0'){
1c000b6c:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b70:	e5d33000 	ldrb	r3, [r3]
1c000b74:	e3530030 	cmp	r3, #48	; 0x30
1c000b78:	1a00000a 	bne	1c000ba8 <vsprintk+0xe8>
				/* zero padding!*/
				/* skip 0 */
				++fmt;
1c000b7c:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b80:	e2833001 	add	r3, r3, #1
1c000b84:	e50b3084 	str	r3, [fp, #-132]	; 0xffffff7c
				zero_padding = *fmt++;
1c000b88:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000b8c:	e2832001 	add	r2, r3, #1
1c000b90:	e50b2084 	str	r2, [fp, #-132]	; 0xffffff7c
1c000b94:	e5d33000 	ldrb	r3, [r3]
1c000b98:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
				if((zero_padding < 0x31) || (zero_padding > 0x38)){
					/* serial_puts("invalid padding bits.\0"); */
				}
				zero_padding -= 0x30;
1c000b9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c000ba0:	e2433030 	sub	r3, r3, #48	; 0x30
1c000ba4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
			}

			switch(*fmt){
1c000ba8:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000bac:	e5d33000 	ldrb	r3, [r3]
1c000bb0:	e353006c 	cmp	r3, #108	; 0x6c
1c000bb4:	1a000003 	bne	1c000bc8 <vsprintk+0x108>
				case 'l':
					{
						++fmt;
1c000bb8:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000bbc:	e2833001 	add	r3, r3, #1
1c000bc0:	e50b3084 	str	r3, [fp, #-132]	; 0xffffff7c
						break;
1c000bc4:	e320f000 	nop	{0}
					}
			}

			switch(*fmt){
1c000bc8:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c000bcc:	e5d33000 	ldrb	r3, [r3]
1c000bd0:	e3530064 	cmp	r3, #100	; 0x64
1c000bd4:	0a00007d 	beq	1c000dd0 <vsprintk+0x310>
1c000bd8:	e3530064 	cmp	r3, #100	; 0x64
1c000bdc:	ca00000b 	bgt	1c000c10 <vsprintk+0x150>
1c000be0:	e353000a 	cmp	r3, #10
1c000be4:	0a000189 	beq	1c001210 <vsprintk+0x750>
1c000be8:	e353000a 	cmp	r3, #10
1c000bec:	ca000002 	bgt	1c000bfc <vsprintk+0x13c>
1c000bf0:	e3530009 	cmp	r3, #9
1c000bf4:	0a000179 	beq	1c0011e0 <vsprintk+0x720>
1c000bf8:	ea000195 	b	1c001254 <vsprintk+0x794>
1c000bfc:	e3530025 	cmp	r3, #37	; 0x25
1c000c00:	0a00016f 	beq	1c0011c4 <vsprintk+0x704>
1c000c04:	e3530063 	cmp	r3, #99	; 0x63
1c000c08:	0a000161 	beq	1c001194 <vsprintk+0x6d4>
1c000c0c:	ea000190 	b	1c001254 <vsprintk+0x794>
1c000c10:	e3530073 	cmp	r3, #115	; 0x73
1c000c14:	0a000143 	beq	1c001128 <vsprintk+0x668>
1c000c18:	e3530073 	cmp	r3, #115	; 0x73
1c000c1c:	ca000004 	bgt	1c000c34 <vsprintk+0x174>
1c000c20:	e3530069 	cmp	r3, #105	; 0x69
1c000c24:	0a000069 	beq	1c000dd0 <vsprintk+0x310>
1c000c28:	e353006f 	cmp	r3, #111	; 0x6f
1c000c2c:	0a0000e0 	beq	1c000fb4 <vsprintk+0x4f4>
1c000c30:	ea000187 	b	1c001254 <vsprintk+0x794>
1c000c34:	e3530075 	cmp	r3, #117	; 0x75
1c000c38:	0a000062 	beq	1c000dc8 <vsprintk+0x308>
1c000c3c:	e3530078 	cmp	r3, #120	; 0x78
1c000c40:	1a000183 	bne	1c001254 <vsprintk+0x794>
				case 'x':
					{
						uint32_t number = va_arg(args, int);
1c000c44:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000c48:	e2833004 	add	r3, r3, #4
1c000c4c:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c000c50:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000c54:	e2433004 	sub	r3, r3, #4
1c000c58:	e5933000 	ldr	r3, [r3]
1c000c5c:	e50b3050 	str	r3, [fp, #-80]	; 0xffffffb0
						int length = 8;
1c000c60:	e3a03008 	mov	r3, #8
1c000c64:	e50b3054 	str	r3, [fp, #-84]	; 0xffffffac
						int length_in_bits = 32;
1c000c68:	e3a03020 	mov	r3, #32
1c000c6c:	e50b3058 	str	r3, [fp, #-88]	; 0xffffffa8
						int byte = 0;
1c000c70:	e3a03000 	mov	r3, #0
1c000c74:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
						int i = 0;
1c000c78:	e3a03000 	mov	r3, #0
1c000c7c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
						uint8_t keep_zeros = FALSE;
1c000c80:	e3a03000 	mov	r3, #0
1c000c84:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3

						for(i = 0; i < length; i++){
1c000c88:	e3a03000 	mov	r3, #0
1c000c8c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
1c000c90:	ea000047 	b	1c000db4 <vsprintk+0x2f4>
							byte = number >> (length_in_bits - ((i+1) * 4));
1c000c94:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c000c98:	e2833001 	add	r3, r3, #1
1c000c9c:	e1a03103 	lsl	r3, r3, #2
1c000ca0:	e51b2058 	ldr	r2, [fp, #-88]	; 0xffffffa8
1c000ca4:	e0423003 	sub	r3, r2, r3
1c000ca8:	e51b2050 	ldr	r2, [fp, #-80]	; 0xffffffb0
1c000cac:	e1a03332 	lsr	r3, r2, r3
1c000cb0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
							byte = byte & 0xF;
1c000cb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000cb8:	e203300f 	and	r3, r3, #15
1c000cbc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
							if(byte != 0){
1c000cc0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000cc4:	e3530000 	cmp	r3, #0
1c000cc8:	0a000001 	beq	1c000cd4 <vsprintk+0x214>
								keep_zeros = TRUE;
1c000ccc:	e3a03001 	mov	r3, #1
1c000cd0:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
							}
							if(keep_zeros || i >= (7-(zero_padding-1))){
1c000cd4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
1c000cd8:	e3530000 	cmp	r3, #0
1c000cdc:	1a000004 	bne	1c000cf4 <vsprintk+0x234>
1c000ce0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c000ce4:	e2632008 	rsb	r2, r3, #8
1c000ce8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c000cec:	e1520003 	cmp	r2, r3
1c000cf0:	8a00002c 	bhi	1c000da8 <vsprintk+0x2e8>
								if((byte >= 0) && (byte <= 9)){
1c000cf4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000cf8:	e3530000 	cmp	r3, #0
1c000cfc:	ba000006 	blt	1c000d1c <vsprintk+0x25c>
1c000d00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000d04:	e3530009 	cmp	r3, #9
1c000d08:	ca000003 	bgt	1c000d1c <vsprintk+0x25c>
									byte = byte + 0x30;
1c000d0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000d10:	e2833030 	add	r3, r3, #48	; 0x30
1c000d14:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
1c000d18:	ea00001c 	b	1c000d90 <vsprintk+0x2d0>
								}
								else{
									switch(byte){
1c000d1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c000d20:	e243300a 	sub	r3, r3, #10
1c000d24:	e3530005 	cmp	r3, #5
1c000d28:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1c000d2c:	ea000017 	b	1c000d90 <vsprintk+0x2d0>
1c000d30:	1c000d48 	.word	0x1c000d48
1c000d34:	1c000d54 	.word	0x1c000d54
1c000d38:	1c000d60 	.word	0x1c000d60
1c000d3c:	1c000d6c 	.word	0x1c000d6c
1c000d40:	1c000d78 	.word	0x1c000d78
1c000d44:	1c000d84 	.word	0x1c000d84
										case 0xa:
											byte = 0x61;
1c000d48:	e3a03061 	mov	r3, #97	; 0x61
1c000d4c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d50:	ea00000e 	b	1c000d90 <vsprintk+0x2d0>
										case 0xb:
											byte = 0x62;
1c000d54:	e3a03062 	mov	r3, #98	; 0x62
1c000d58:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d5c:	ea00000b 	b	1c000d90 <vsprintk+0x2d0>
										case 0xc:
											byte = 0x63;
1c000d60:	e3a03063 	mov	r3, #99	; 0x63
1c000d64:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d68:	ea000008 	b	1c000d90 <vsprintk+0x2d0>
										case 0xd:
											byte = 0x64;
1c000d6c:	e3a03064 	mov	r3, #100	; 0x64
1c000d70:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d74:	ea000005 	b	1c000d90 <vsprintk+0x2d0>
										case 0xe:
											byte = 0x65;
1c000d78:	e3a03065 	mov	r3, #101	; 0x65
1c000d7c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d80:	ea000002 	b	1c000d90 <vsprintk+0x2d0>
										case 0xf:
											byte = 0x66;
1c000d84:	e3a03066 	mov	r3, #102	; 0x66
1c000d88:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
											break;
1c000d8c:	e320f000 	nop	{0}
									} /* switch ends */
								} /* else ends */
								*str++ = byte;
1c000d90:	e51b3008 	ldr	r3, [fp, #-8]
1c000d94:	e2832001 	add	r2, r3, #1
1c000d98:	e50b2008 	str	r2, [fp, #-8]
1c000d9c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
1c000da0:	e6ef2072 	uxtb	r2, r2
1c000da4:	e5c32000 	strb	r2, [r3]
						for(i = 0; i < length; i++){
1c000da8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c000dac:	e2833001 	add	r3, r3, #1
1c000db0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
1c000db4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c000db8:	e51b3054 	ldr	r3, [fp, #-84]	; 0xffffffac
1c000dbc:	e1520003 	cmp	r2, r3
1c000dc0:	baffffb3 	blt	1c000c94 <vsprintk+0x1d4>
							}
						} /* for ends - whole number is now done */
						break;
1c000dc4:	ea000122 	b	1c001254 <vsprintk+0x794>
					}
				case 'u':
					is_unsigned = 1;
1c000dc8:	e3a03001 	mov	r3, #1
1c000dcc:	e50b3010 	str	r3, [fp, #-16]
				case 'i':
				case 'd':
					{
						uint32_t i,j,max_num_zeros,num_of_digits_uint32_t,
								number_uint32_t,divisor_value_uint32_t,
								new_div_val = 1,sw_quotient_value = 0;
1c000dd0:	e3a03001 	mov	r3, #1
1c000dd4:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
1c000dd8:	e3a03000 	mov	r3, #0
1c000ddc:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
						uint8_t keep_zeros = FALSE;
1c000de0:	e3a03000 	mov	r3, #0
1c000de4:	e54b3039 	strb	r3, [fp, #-57]	; 0xffffffc7

						if(!is_unsigned){
1c000de8:	e51b3010 	ldr	r3, [fp, #-16]
1c000dec:	e3530000 	cmp	r3, #0
1c000df0:	1a000013 	bne	1c000e44 <vsprintk+0x384>
							int signed_num_32 = va_arg(args,int);
1c000df4:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000df8:	e2833004 	add	r3, r3, #4
1c000dfc:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c000e00:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000e04:	e5133004 	ldr	r3, [r3, #-4]
1c000e08:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0
							if(signed_num_32 < 0){
1c000e0c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
1c000e10:	e3530000 	cmp	r3, #0
1c000e14:	aa000007 	bge	1c000e38 <vsprintk+0x378>
								*str++ = 0x2d;
1c000e18:	e51b3008 	ldr	r3, [fp, #-8]
1c000e1c:	e2832001 	add	r2, r3, #1
1c000e20:	e50b2008 	str	r2, [fp, #-8]
1c000e24:	e3a0202d 	mov	r2, #45	; 0x2d
1c000e28:	e5c32000 	strb	r2, [r3]
								signed_num_32 = -(signed_num_32);
1c000e2c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
1c000e30:	e2633000 	rsb	r3, r3, #0
1c000e34:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0
							}
							number_uint32_t = (uint32_t)signed_num_32;
1c000e38:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
1c000e3c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
1c000e40:	ea000007 	b	1c000e64 <vsprintk+0x3a4>
						}
						else{
							uint32_t unsigned_value_32 = va_arg(args,
1c000e44:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000e48:	e2833004 	add	r3, r3, #4
1c000e4c:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c000e50:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000e54:	e5133004 	ldr	r3, [r3, #-4]
1c000e58:	e50b305c 	str	r3, [fp, #-92]	; 0xffffffa4
									unsigned int);
							number_uint32_t = unsigned_value_32;
1c000e5c:	e51b305c 	ldr	r3, [fp, #-92]	; 0xffffffa4
1c000e60:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
						}

						divisor_value_uint32_t = 1000000000;
1c000e64:	e3a03cca 	mov	r3, #51712	; 0xca00
1c000e68:	e3433b9a 	movt	r3, #15258	; 0x3b9a
1c000e6c:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
						num_of_digits_uint32_t = 10;
1c000e70:	e3a0300a 	mov	r3, #10
1c000e74:	e50b3060 	str	r3, [fp, #-96]	; 0xffffffa0
						max_num_zeros = num_of_digits_uint32_t - 1;
1c000e78:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
1c000e7c:	e2433001 	sub	r3, r3, #1
1c000e80:	e50b3064 	str	r3, [fp, #-100]	; 0xffffff9c

						for(i = 0; i < max_num_zeros; i++){
1c000e84:	e3a03000 	mov	r3, #0
1c000e88:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
1c000e8c:	ea00003b 	b	1c000f80 <vsprintk+0x4c0>
							while(number_uint32_t >= divisor_value_uint32_t){
								number_uint32_t -= divisor_value_uint32_t;
1c000e90:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
1c000e94:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
1c000e98:	e0423003 	sub	r3, r2, r3
1c000e9c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
								++sw_quotient_value;
1c000ea0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
1c000ea4:	e2833001 	add	r3, r3, #1
1c000ea8:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
							while(number_uint32_t >= divisor_value_uint32_t){
1c000eac:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
1c000eb0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
1c000eb4:	e1520003 	cmp	r2, r3
1c000eb8:	2afffff4 	bcs	1c000e90 <vsprintk+0x3d0>
							}
							if(sw_quotient_value != 0)
1c000ebc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
1c000ec0:	e3530000 	cmp	r3, #0
1c000ec4:	0a000001 	beq	1c000ed0 <vsprintk+0x410>
								keep_zeros = TRUE;
1c000ec8:	e3a03001 	mov	r3, #1
1c000ecc:	e54b3039 	strb	r3, [fp, #-57]	; 0xffffffc7
							if(keep_zeros || i > ((max_num_zeros-1)-
1c000ed0:	e55b3039 	ldrb	r3, [fp, #-57]	; 0xffffffc7
1c000ed4:	e3530000 	cmp	r3, #0
1c000ed8:	1a000005 	bne	1c000ef4 <vsprintk+0x434>
1c000edc:	e51b2064 	ldr	r2, [fp, #-100]	; 0xffffff9c
1c000ee0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c000ee4:	e0422003 	sub	r2, r2, r3
1c000ee8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
1c000eec:	e1520003 	cmp	r2, r3
1c000ef0:	2a000008 	bcs	1c000f18 <vsprintk+0x458>
										(zero_padding-1))){
								sw_quotient_value += 0x30;
1c000ef4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
1c000ef8:	e2833030 	add	r3, r3, #48	; 0x30
1c000efc:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
								*str++ = sw_quotient_value;
1c000f00:	e51b3008 	ldr	r3, [fp, #-8]
1c000f04:	e2832001 	add	r2, r3, #1
1c000f08:	e50b2008 	str	r2, [fp, #-8]
1c000f0c:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
1c000f10:	e6ef2072 	uxtb	r2, r2
1c000f14:	e5c32000 	strb	r2, [r3]
							}
							j = i;
1c000f18:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
1c000f1c:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
							while(j < (max_num_zeros-1)){
1c000f20:	ea000008 	b	1c000f48 <vsprintk+0x488>
								new_div_val *= 10;
1c000f24:	e51b2034 	ldr	r2, [fp, #-52]	; 0xffffffcc
1c000f28:	e1a03002 	mov	r3, r2
1c000f2c:	e1a03103 	lsl	r3, r3, #2
1c000f30:	e0833002 	add	r3, r3, r2
1c000f34:	e1a03083 	lsl	r3, r3, #1
1c000f38:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
								j++;
1c000f3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
1c000f40:	e2833001 	add	r3, r3, #1
1c000f44:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
							while(j < (max_num_zeros-1)){
1c000f48:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
1c000f4c:	e2432001 	sub	r2, r3, #1
1c000f50:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
1c000f54:	e1520003 	cmp	r2, r3
1c000f58:	8afffff1 	bhi	1c000f24 <vsprintk+0x464>
							}
							sw_quotient_value = 0;
1c000f5c:	e3a03000 	mov	r3, #0
1c000f60:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
							divisor_value_uint32_t = new_div_val;
1c000f64:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
1c000f68:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
							new_div_val = 1;
1c000f6c:	e3a03001 	mov	r3, #1
1c000f70:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
						for(i = 0; i < max_num_zeros; i++){
1c000f74:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
1c000f78:	e2833001 	add	r3, r3, #1
1c000f7c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
1c000f80:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
1c000f84:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
1c000f88:	e1520003 	cmp	r2, r3
1c000f8c:	3affffc6 	bcc	1c000eac <vsprintk+0x3ec>
						}
						*str++ = (number_uint32_t + 0x30);
1c000f90:	e51b3008 	ldr	r3, [fp, #-8]
1c000f94:	e2832001 	add	r2, r3, #1
1c000f98:	e50b2008 	str	r2, [fp, #-8]
1c000f9c:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
1c000fa0:	e6ef2072 	uxtb	r2, r2
1c000fa4:	e2822030 	add	r2, r2, #48	; 0x30
1c000fa8:	e6ef2072 	uxtb	r2, r2
1c000fac:	e5c32000 	strb	r2, [r3]
						break;
1c000fb0:	ea0000a7 	b	1c001254 <vsprintk+0x794>
					}
				case 'o':
					{
						uint32_t number,length = 10,length_in_bits = 32,
1c000fb4:	e3a0300a 	mov	r3, #10
1c000fb8:	e50b3068 	str	r3, [fp, #-104]	; 0xffffff98
1c000fbc:	e3a03020 	mov	r3, #32
1c000fc0:	e50b306c 	str	r3, [fp, #-108]	; 0xffffff94
								byte = 0,i = 0;
1c000fc4:	e3a03000 	mov	r3, #0
1c000fc8:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
1c000fcc:	e3a03000 	mov	r3, #0
1c000fd0:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
						uint8_t keep_zeros = FALSE;
1c000fd4:	e3a03000 	mov	r3, #0
1c000fd8:	e54b3045 	strb	r3, [fp, #-69]	; 0xffffffbb

						number = va_arg(args, int);
1c000fdc:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000fe0:	e2833004 	add	r3, r3, #4
1c000fe4:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c000fe8:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c000fec:	e2433004 	sub	r3, r3, #4
1c000ff0:	e5933000 	ldr	r3, [r3]
1c000ff4:	e50b3074 	str	r3, [fp, #-116]	; 0xffffff8c
						byte = number >> 30;
1c000ff8:	e51b3074 	ldr	r3, [fp, #-116]	; 0xffffff8c
1c000ffc:	e1a03f23 	lsr	r3, r3, #30
1c001000:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
						byte &= 0x3;
1c001004:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c001008:	e2033003 	and	r3, r3, #3
1c00100c:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
						if(byte != 0){
1c001010:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c001014:	e3530000 	cmp	r3, #0
1c001018:	0a000001 	beq	1c001024 <vsprintk+0x564>
							keep_zeros = TRUE;
1c00101c:	e3a03001 	mov	r3, #1
1c001020:	e54b3045 	strb	r3, [fp, #-69]	; 0xffffffbb
						}
						if(keep_zeros || zero_padding > length){
1c001024:	e55b3045 	ldrb	r3, [fp, #-69]	; 0xffffffbb
1c001028:	e3530000 	cmp	r3, #0
1c00102c:	1a000003 	bne	1c001040 <vsprintk+0x580>
1c001030:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c001034:	e51b3068 	ldr	r3, [fp, #-104]	; 0xffffff98
1c001038:	e1520003 	cmp	r2, r3
1c00103c:	9a000008 	bls	1c001064 <vsprintk+0x5a4>
							byte = byte + 0x30;
1c001040:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c001044:	e2833030 	add	r3, r3, #48	; 0x30
1c001048:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
							*str++ = byte;
1c00104c:	e51b3008 	ldr	r3, [fp, #-8]
1c001050:	e2832001 	add	r2, r3, #1
1c001054:	e50b2008 	str	r2, [fp, #-8]
1c001058:	e51b2070 	ldr	r2, [fp, #-112]	; 0xffffff90
1c00105c:	e6ef2072 	uxtb	r2, r2
1c001060:	e5c32000 	strb	r2, [r3]
						}

						number <<= 2;
1c001064:	e51b3074 	ldr	r3, [fp, #-116]	; 0xffffff8c
1c001068:	e1a03103 	lsl	r3, r3, #2
1c00106c:	e50b3074 	str	r3, [fp, #-116]	; 0xffffff8c
						for(i = 0; i < length; i++){
1c001070:	e3a03000 	mov	r3, #0
1c001074:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
1c001078:	ea000025 	b	1c001114 <vsprintk+0x654>
							byte = number >> (length_in_bits - ((i+1) * 3));
1c00107c:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
1c001080:	e2832001 	add	r2, r3, #1
1c001084:	e1a03002 	mov	r3, r2
1c001088:	e1a03083 	lsl	r3, r3, #1
1c00108c:	e0833002 	add	r3, r3, r2
1c001090:	e51b206c 	ldr	r2, [fp, #-108]	; 0xffffff94
1c001094:	e0423003 	sub	r3, r2, r3
1c001098:	e51b2074 	ldr	r2, [fp, #-116]	; 0xffffff8c
1c00109c:	e1a03332 	lsr	r3, r2, r3
1c0010a0:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
							byte &= 0x7;
1c0010a4:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c0010a8:	e2033007 	and	r3, r3, #7
1c0010ac:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
							if(byte != 0){
1c0010b0:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c0010b4:	e3530000 	cmp	r3, #0
1c0010b8:	0a000001 	beq	1c0010c4 <vsprintk+0x604>
								keep_zeros = TRUE;
1c0010bc:	e3a03001 	mov	r3, #1
1c0010c0:	e54b3045 	strb	r3, [fp, #-69]	; 0xffffffbb
							}
							if(keep_zeros || i >= (9-(zero_padding-1))){
1c0010c4:	e55b3045 	ldrb	r3, [fp, #-69]	; 0xffffffbb
1c0010c8:	e3530000 	cmp	r3, #0
1c0010cc:	1a000004 	bne	1c0010e4 <vsprintk+0x624>
1c0010d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0010d4:	e263200a 	rsb	r2, r3, #10
1c0010d8:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
1c0010dc:	e1520003 	cmp	r2, r3
1c0010e0:	8a000008 	bhi	1c001108 <vsprintk+0x648>
								byte = byte + 0x30;
1c0010e4:	e51b3070 	ldr	r3, [fp, #-112]	; 0xffffff90
1c0010e8:	e2833030 	add	r3, r3, #48	; 0x30
1c0010ec:	e50b3070 	str	r3, [fp, #-112]	; 0xffffff90
								*str++ = byte;
1c0010f0:	e51b3008 	ldr	r3, [fp, #-8]
1c0010f4:	e2832001 	add	r2, r3, #1
1c0010f8:	e50b2008 	str	r2, [fp, #-8]
1c0010fc:	e51b2070 	ldr	r2, [fp, #-112]	; 0xffffff90
1c001100:	e6ef2072 	uxtb	r2, r2
1c001104:	e5c32000 	strb	r2, [r3]
						for(i = 0; i < length; i++){
1c001108:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
1c00110c:	e2833001 	add	r3, r3, #1
1c001110:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
1c001114:	e51b2044 	ldr	r2, [fp, #-68]	; 0xffffffbc
1c001118:	e51b3068 	ldr	r3, [fp, #-104]	; 0xffffff98
1c00111c:	e1520003 	cmp	r2, r3
1c001120:	3affffd5 	bcc	1c00107c <vsprintk+0x5bc>
							}
						}
						break;
1c001124:	ea00004a 	b	1c001254 <vsprintk+0x794>
					}
				case 's':
					{
						char *arg_string = va_arg(args, char *);
1c001128:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c00112c:	e2833004 	add	r3, r3, #4
1c001130:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c001134:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c001138:	e5133004 	ldr	r3, [r3, #-4]
1c00113c:	e50b304c 	str	r3, [fp, #-76]	; 0xffffffb4
						while(((*str = *arg_string++ ) &&
1c001140:	ea000005 	b	1c00115c <vsprintk+0x69c>
									(len < PRINT_TEXT_LEN))){
							++str;
1c001144:	e51b3008 	ldr	r3, [fp, #-8]
1c001148:	e2833001 	add	r3, r3, #1
1c00114c:	e50b3008 	str	r3, [fp, #-8]
							len++;
1c001150:	e51b300c 	ldr	r3, [fp, #-12]
1c001154:	e2833001 	add	r3, r3, #1
1c001158:	e50b300c 	str	r3, [fp, #-12]
						while(((*str = *arg_string++ ) &&
1c00115c:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
1c001160:	e2832001 	add	r2, r3, #1
1c001164:	e50b204c 	str	r2, [fp, #-76]	; 0xffffffb4
1c001168:	e5d32000 	ldrb	r2, [r3]
1c00116c:	e51b3008 	ldr	r3, [fp, #-8]
1c001170:	e5c32000 	strb	r2, [r3]
1c001174:	e51b3008 	ldr	r3, [fp, #-8]
1c001178:	e5d33000 	ldrb	r3, [r3]
1c00117c:	e3530000 	cmp	r3, #0
1c001180:	0a000032 	beq	1c001250 <vsprintk+0x790>
1c001184:	e51b300c 	ldr	r3, [fp, #-12]
1c001188:	e35300ff 	cmp	r3, #255	; 0xff
1c00118c:	9affffec 	bls	1c001144 <vsprintk+0x684>
						}
						break;
1c001190:	ea00002e 	b	1c001250 <vsprintk+0x790>
					}
				case 'c':
					{
						char character = va_arg(args, char);
1c001194:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c001198:	e2833004 	add	r3, r3, #4
1c00119c:	e50b3088 	str	r3, [fp, #-136]	; 0xffffff78
1c0011a0:	e51b3088 	ldr	r3, [fp, #-136]	; 0xffffff78
1c0011a4:	e5533004 	ldrb	r3, [r3, #-4]
1c0011a8:	e54b3075 	strb	r3, [fp, #-117]	; 0xffffff8b
						*str++ = character;
1c0011ac:	e51b3008 	ldr	r3, [fp, #-8]
1c0011b0:	e2832001 	add	r2, r3, #1
1c0011b4:	e50b2008 	str	r2, [fp, #-8]
1c0011b8:	e55b2075 	ldrb	r2, [fp, #-117]	; 0xffffff8b
1c0011bc:	e5c32000 	strb	r2, [r3]
						break;
1c0011c0:	ea000023 	b	1c001254 <vsprintk+0x794>
					}
				case '%':
					{
						*str++ = *fmt;
1c0011c4:	e51b3008 	ldr	r3, [fp, #-8]
1c0011c8:	e2832001 	add	r2, r3, #1
1c0011cc:	e50b2008 	str	r2, [fp, #-8]
1c0011d0:	e51b2084 	ldr	r2, [fp, #-132]	; 0xffffff7c
1c0011d4:	e5d22000 	ldrb	r2, [r2]
1c0011d8:	e5c32000 	strb	r2, [r3]
						break;
1c0011dc:	ea00001c 	b	1c001254 <vsprintk+0x794>
					}
				case '\t':
					{
						*str++ = '%';
1c0011e0:	e51b3008 	ldr	r3, [fp, #-8]
1c0011e4:	e2832001 	add	r2, r3, #1
1c0011e8:	e50b2008 	str	r2, [fp, #-8]
1c0011ec:	e3a02025 	mov	r2, #37	; 0x25
1c0011f0:	e5c32000 	strb	r2, [r3]
						*str++ = *fmt;
1c0011f4:	e51b3008 	ldr	r3, [fp, #-8]
1c0011f8:	e2832001 	add	r2, r3, #1
1c0011fc:	e50b2008 	str	r2, [fp, #-8]
1c001200:	e51b2084 	ldr	r2, [fp, #-132]	; 0xffffff7c
1c001204:	e5d22000 	ldrb	r2, [r2]
1c001208:	e5c32000 	strb	r2, [r3]
						break;
1c00120c:	ea000010 	b	1c001254 <vsprintk+0x794>
					}
				case '\n':
					{
						*str++ = '%';
1c001210:	e51b3008 	ldr	r3, [fp, #-8]
1c001214:	e2832001 	add	r2, r3, #1
1c001218:	e50b2008 	str	r2, [fp, #-8]
1c00121c:	e3a02025 	mov	r2, #37	; 0x25
1c001220:	e5c32000 	strb	r2, [r3]
						*str++ = '\r';
1c001224:	e51b3008 	ldr	r3, [fp, #-8]
1c001228:	e2832001 	add	r2, r3, #1
1c00122c:	e50b2008 	str	r2, [fp, #-8]
1c001230:	e3a0200d 	mov	r2, #13
1c001234:	e5c32000 	strb	r2, [r3]
						*str++ = '\n';
1c001238:	e51b3008 	ldr	r3, [fp, #-8]
1c00123c:	e2832001 	add	r2, r3, #1
1c001240:	e50b2008 	str	r2, [fp, #-8]
1c001244:	e3a0200a 	mov	r2, #10
1c001248:	e5c32000 	strb	r2, [r3]
						break;
1c00124c:	ea000000 	b	1c001254 <vsprintk+0x794>
						break;
1c001250:	e320f000 	nop	{0}

					}
			} /* switch ends             */
		} /* if % character found      */

		if(*fmt == '\n'){
1c001254:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c001258:	e5d33000 	ldrb	r3, [r3]
1c00125c:	e353000a 	cmp	r3, #10
1c001260:	1a000009 	bne	1c00128c <vsprintk+0x7cc>
			*str++ = '\r';
1c001264:	e51b3008 	ldr	r3, [fp, #-8]
1c001268:	e2832001 	add	r2, r3, #1
1c00126c:	e50b2008 	str	r2, [fp, #-8]
1c001270:	e3a0200d 	mov	r2, #13
1c001274:	e5c32000 	strb	r2, [r3]
			*str++ = '\n';
1c001278:	e51b3008 	ldr	r3, [fp, #-8]
1c00127c:	e2832001 	add	r2, r3, #1
1c001280:	e50b2008 	str	r2, [fp, #-8]
1c001284:	e3a0200a 	mov	r2, #10
1c001288:	e5c32000 	strb	r2, [r3]
		}
		if(*fmt == '\t')
1c00128c:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c001290:	e5d33000 	ldrb	r3, [r3]
1c001294:	e3530009 	cmp	r3, #9
1c001298:	1a000005 	bne	1c0012b4 <vsprintk+0x7f4>
			*str++ = *fmt;
1c00129c:	e51b3008 	ldr	r3, [fp, #-8]
1c0012a0:	e2832001 	add	r2, r3, #1
1c0012a4:	e50b2008 	str	r2, [fp, #-8]
1c0012a8:	e51b2084 	ldr	r2, [fp, #-132]	; 0xffffff7c
1c0012ac:	e5d22000 	ldrb	r2, [r2]
1c0012b0:	e5c32000 	strb	r2, [r3]
	for(; *fmt ; ++fmt){
1c0012b4:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c0012b8:	e2833001 	add	r3, r3, #1
1c0012bc:	e50b3084 	str	r3, [fp, #-132]	; 0xffffff7c
1c0012c0:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
1c0012c4:	e5d33000 	ldrb	r3, [r3]
1c0012c8:	e3530000 	cmp	r3, #0
1c0012cc:	1afffe08 	bne	1c000af4 <vsprintk+0x34>
	} /* for ends */
	*str = '\0';
1c0012d0:	e51b3008 	ldr	r3, [fp, #-8]
1c0012d4:	e3a02000 	mov	r2, #0
1c0012d8:	e5c32000 	strb	r2, [r3]
	return strnlen(buf,PRINT_TEXT_LEN);
1c0012dc:	e3a01c01 	mov	r1, #256	; 0x100
1c0012e0:	e51b0080 	ldr	r0, [fp, #-128]	; 0xffffff80
1c0012e4:	ebfffdc2 	bl	1c0009f4 <strnlen>
1c0012e8:	e1a03000 	mov	r3, r0
}
1c0012ec:	e1a00003 	mov	r0, r3
1c0012f0:	e24bd004 	sub	sp, fp, #4
1c0012f4:	e8bd8800 	pop	{fp, pc}

1c0012f8 <printk>:

uint32_t printk(const char *fmt, ...){
1c0012f8:	e92d000f 	push	{r0, r1, r2, r3}
1c0012fc:	e92d4800 	push	{fp, lr}
1c001300:	e28db004 	add	fp, sp, #4
1c001304:	e24ddf42 	sub	sp, sp, #264	; 0x108

	va_list args;
	uint32_t i;
	char print_buffer[256];
	va_start(args, fmt);
1c001308:	e28b3008 	add	r3, fp, #8
1c00130c:	e50b3008 	str	r3, [fp, #-8]

	i = vsprintk(print_buffer, fmt, args);
1c001310:	e59b1004 	ldr	r1, [fp, #4]
1c001314:	e24b3f43 	sub	r3, fp, #268	; 0x10c
1c001318:	e51b2008 	ldr	r2, [fp, #-8]
1c00131c:	e1a00003 	mov	r0, r3
1c001320:	ebfffde6 	bl	1c000ac0 <vsprintk>
1c001324:	e50b000c 	str	r0, [fp, #-12]
	va_end(args);

	/* Print the string */
	serial_puts(print_buffer);
1c001328:	e24b3f43 	sub	r3, fp, #268	; 0x10c
1c00132c:	e1a01003 	mov	r1, r3
1c001330:	e3a00001 	mov	r0, #1
1c001334:	eb000464 	bl	1c0024cc <uart_puts>
	return i;
1c001338:	e51b300c 	ldr	r3, [fp, #-12]
}
1c00133c:	e1a00003 	mov	r0, r3
1c001340:	e24bd004 	sub	sp, fp, #4
1c001344:	e8bd4800 	pop	{fp, lr}
1c001348:	e28dd010 	add	sp, sp, #16
1c00134c:	e12fff1e 	bx	lr

1c001350 <read32>:
 *
 * @param	addr = pointer of address
 *
 * @retval  value pointed by addr
 */
inline uint32_t read32( volatile void * addr ){
1c001350:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001354:	e28db000 	add	fp, sp, #0
1c001358:	e24dd00c 	sub	sp, sp, #12
1c00135c:	e50b0008 	str	r0, [fp, #-8]

	return *(uint32_t*)addr;
1c001360:	e51b3008 	ldr	r3, [fp, #-8]
1c001364:	e5933000 	ldr	r3, [r3]
}
1c001368:	e1a00003 	mov	r0, r3
1c00136c:	e24bd000 	sub	sp, fp, #0
1c001370:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001374:	e12fff1e 	bx	lr

1c001378 <write32>:
 * @param	addr = pointer of address
 * 		data = value
 *
 * @retval  
 */
inline void write32( volatile void *addr, uint32_t data ){
1c001378:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c00137c:	e28db000 	add	fp, sp, #0
1c001380:	e24dd00c 	sub	sp, sp, #12
1c001384:	e50b0008 	str	r0, [fp, #-8]
1c001388:	e50b100c 	str	r1, [fp, #-12]

	*(uint32_t*)addr = data;
1c00138c:	e51b3008 	ldr	r3, [fp, #-8]
1c001390:	e51b200c 	ldr	r2, [fp, #-12]
1c001394:	e5832000 	str	r2, [r3]
}
1c001398:	e320f000 	nop	{0}
1c00139c:	e24bd000 	sub	sp, fp, #0
1c0013a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0013a4:	e12fff1e 	bx	lr

1c0013a8 <ltzvisor_init>:
 *
 * @param  
 *
 * @retval 
 */
uint32_t ltzvisor_init(void){
1c0013a8:	e92d4800 	push	{fp, lr}
1c0013ac:	e28db004 	add	fp, sp, #4
1c0013b0:	e24dd008 	sub	sp, sp, #8

	uint32_t ret;

	/** Initialize LTZVisor-related hardware*/
	ret = ltzvisor_hw_init();
1c0013b4:	eb0005f5 	bl	1c002b90 <ltzvisor_hw_init>
1c0013b8:	e50b0008 	str	r0, [fp, #-8]

	/** Perform other hypervisor-related initializations here*/

	return ret;
1c0013bc:	e51b3008 	ldr	r3, [fp, #-8]
}
1c0013c0:	e1a00003 	mov	r0, r3
1c0013c4:	e24bd004 	sub	sp, fp, #4
1c0013c8:	e8bd8800 	pop	{fp, pc}

1c0013cc <ltzvisor_kickoff>:
 *
 * @param  
 *
 * @retval 
 */
void ltzvisor_kickoff(void){
1c0013cc:	e92d4800 	push	{fp, lr}
1c0013d0:	e28db004 	add	fp, sp, #4

	/** Exit from Monitor mode */
	LTZVISOR_MON_EXIT();
1c0013d4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
1c0013d8:	f57ff04f 	dsb	sy
1c0013dc:	f57ff06f 	isb	sy

	// iCache_enable();
	// dCache_enable();
	// mmu_enable();
	dCache_clean();
1c0013e0:	ebfffc43 	bl	1c0004f4 <dCache_clean>
	cachel2_clean();
1c0013e4:	eb0006f8 	bl	1c002fcc <cachel2_clean>

	/** Secure guest entry point */
	_start();
1c0013e8:	e3093838 	movw	r3, #38968	; 0x9838
1c0013ec:	e3413c03 	movt	r3, #7171	; 0x1c03
1c0013f0:	e5933000 	ldr	r3, [r3]
1c0013f4:	e12fff33 	blx	r3

	/** This point should never be reached */
	while(1);	
1c0013f8:	eafffffe 	b	1c0013f8 <ltzvisor_kickoff+0x2c>

1c0013fc <ltzvisor_schedule>:
 *
 * @param  
 *
 * @retval 
 */
void ltzvisor_schedule(void){
1c0013fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001400:	e28db000 	add	fp, sp, #0

	/** TODO - In case implementing a different scheduling policy */
	while(1);
1c001404:	eafffffe 	b	1c001404 <ltzvisor_schedule+0x8>

1c001408 <ltzvisor_nsguest_create>:
 * @param  	g = pointer to guest configuration
 *
 * @retval 	TRUE if goes well; FALSE if not!
 */
uint32_t ltzvisor_nsguest_create( struct guest_conf *g )
{
1c001408:	e92d4800 	push	{fp, lr}
1c00140c:	e28db004 	add	fp, sp, #4
1c001410:	e24dd008 	sub	sp, sp, #8
1c001414:	e50b0008 	str	r0, [fp, #-8]

	/** Init Guest attributes */
	NS_Guest.booting = 1;
1c001418:	e309383c 	movw	r3, #38972	; 0x983c
1c00141c:	e3413c03 	movt	r3, #7171	; 0x1c03
1c001420:	e3a02001 	mov	r2, #1
1c001424:	e58320fc 	str	r2, [r3, #252]	; 0xfc
	NS_Guest.id = g->gce_id;
1c001428:	e51b3008 	ldr	r3, [fp, #-8]
1c00142c:	e5932020 	ldr	r2, [r3, #32]
1c001430:	e309383c 	movw	r3, #38972	; 0x983c
1c001434:	e3413c03 	movt	r3, #7171	; 0x1c03
1c001438:	e58320f8 	str	r2, [r3, #248]	; 0xf8
	strcpy(NS_Guest.name, g->gce_name);
1c00143c:	e51b3008 	ldr	r3, [fp, #-8]
1c001440:	e1a01003 	mov	r1, r3
1c001444:	e59f01a0 	ldr	r0, [pc, #416]	; 1c0015ec <ltzvisor_nsguest_create+0x1e4>
1c001448:	ebfffd84 	bl	1c000a60 <strcpy>
	printk("      * NS_Guest attributes - OK  \n\t");
1c00144c:	e3030294 	movw	r0, #12948	; 0x3294
1c001450:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001454:	ebffffa7 	bl	1c0012f8 <printk>

	/** Guest Core Registers */
	/* Clean core registers */
	memset(&NS_Guest.core.vcpu_regs_core,0,sizeof(struct core_regs));
1c001458:	e3a02078 	mov	r2, #120	; 0x78
1c00145c:	e3a01000 	mov	r1, #0
1c001460:	e309083c 	movw	r0, #38972	; 0x983c
1c001464:	e3410c03 	movt	r0, #7171	; 0x1c03
1c001468:	ebfffd12 	bl	1c0008b8 <memset>
	/* lr = start_addr & spsr=supervisor */
	NS_Guest.core.vcpu_regs_core.lr_mon = g->gce_bin_load;
1c00146c:	e51b3008 	ldr	r3, [fp, #-8]
1c001470:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
1c001474:	e309383c 	movw	r3, #38972	; 0x983c
1c001478:	e3413c03 	movt	r3, #7171	; 0x1c03
1c00147c:	e5832038 	str	r2, [r3, #56]	; 0x38
	NS_Guest.core.vcpu_regs_core.spsr_mon = 0x193;
1c001480:	e309383c 	movw	r3, #38972	; 0x983c
1c001484:	e3413c03 	movt	r3, #7171	; 0x1c03
1c001488:	e3002193 	movw	r2, #403	; 0x193
1c00148c:	e5832034 	str	r2, [r3, #52]	; 0x34
	printk("      * NS_Guest core registers - OK  \n\t");
1c001490:	e30302bc 	movw	r0, #12988	; 0x32bc
1c001494:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001498:	ebffff96 	bl	1c0012f8 <printk>

	/** Guest CP15 Registers */
	/* Clean CP15 registers */
	memset(&NS_Guest.core.vcpu_regs_cp15,0,sizeof(struct cp15_regs));
1c00149c:	e3a02050 	mov	r2, #80	; 0x50
1c0014a0:	e3a01000 	mov	r1, #0
1c0014a4:	e59f0144 	ldr	r0, [pc, #324]	; 1c0015f0 <ltzvisor_nsguest_create+0x1e8>
1c0014a8:	ebfffd02 	bl	1c0008b8 <memset>
	NS_Guest.core.vcpu_regs_cp15.c1_SCTLR = 0x00c50078;
1c0014ac:	e309283c 	movw	r2, #38972	; 0x983c
1c0014b0:	e3412c03 	movt	r2, #7171	; 0x1c03
1c0014b4:	e3a03078 	mov	r3, #120	; 0x78
1c0014b8:	e34030c5 	movt	r3, #197	; 0xc5
1c0014bc:	e582307c 	str	r3, [r2, #124]	; 0x7c
	printk("      * NS_Guest CP15 registers - OK  \n\t");
1c0014c0:	e30302e8 	movw	r0, #13032	; 0x32e8
1c0014c4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0014c8:	ebffff8a 	bl	1c0012f8 <printk>

//	#ifdef CONFIG_CACHE_L2X0
		NS_Guest.core.vcpu_regs_cp15.c1_ACTLR = 0x00000006; /* L1 prefetch enable -bit2- + L2 Prefetch hint enable -bit1-*/
1c0014cc:	e309383c 	movw	r3, #38972	; 0x983c
1c0014d0:	e3413c03 	movt	r3, #7171	; 0x1c03
1c0014d4:	e3a02006 	mov	r2, #6
1c0014d8:	e5832080 	str	r2, [r3, #128]	; 0x80
		printk("      * NS_Guest L2 Cache - OK  \n\t");
1c0014dc:	e3030314 	movw	r0, #13076	; 0x3314
1c0014e0:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0014e4:	ebffff83 	bl	1c0012f8 <printk>
//	#endif

	/** Load Guest bin to Non-Secure Memory */
	printk("      * NS_Guest loading ...  \n\t");
1c0014e8:	e3030338 	movw	r0, #13112	; 0x3338
1c0014ec:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0014f0:	ebffff80 	bl	1c0012f8 <printk>
	printk("      * NS_Guest gce_bin_load: 0x%x \n\t", g->gce_bin_load);
1c0014f4:	e51b3008 	ldr	r3, [fp, #-8]
1c0014f8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1c0014fc:	e1a01003 	mov	r1, r3
1c001500:	e303035c 	movw	r0, #13148	; 0x335c
1c001504:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001508:	ebffff7a 	bl	1c0012f8 <printk>
	printk("      * NS_Guest gce_bin_start: 0x%x \n\t", g->gce_bin_start);
1c00150c:	e51b3008 	ldr	r3, [fp, #-8]
1c001510:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001514:	e1a01003 	mov	r1, r3
1c001518:	e3030384 	movw	r0, #13188	; 0x3384
1c00151c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001520:	ebffff74 	bl	1c0012f8 <printk>
	printk("      * NS_Guest gce_bin_end: 0x%x \n\t", g->gce_bin_end);
1c001524:	e51b3008 	ldr	r3, [fp, #-8]
1c001528:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1c00152c:	e1a01003 	mov	r1, r3
1c001530:	e30303ac 	movw	r0, #13228	; 0x33ac
1c001534:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001538:	ebffff6e 	bl	1c0012f8 <printk>
	memcpy((uint32_t *)g->gce_bin_load,(uint32_t *)g->gce_bin_start,(g->gce_bin_end - g->gce_bin_start));
1c00153c:	e51b3008 	ldr	r3, [fp, #-8]
1c001540:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1c001544:	e1a00003 	mov	r0, r3
1c001548:	e51b3008 	ldr	r3, [fp, #-8]
1c00154c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001550:	e1a01003 	mov	r1, r3
1c001554:	e51b3008 	ldr	r3, [fp, #-8]
1c001558:	e5932038 	ldr	r2, [r3, #56]	; 0x38
1c00155c:	e51b3008 	ldr	r3, [fp, #-8]
1c001560:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001564:	e0423003 	sub	r3, r2, r3
1c001568:	e1a02003 	mov	r2, r3
1c00156c:	ebfffc73 	bl	1c000740 <memcpy>
	if(g->gce_trd_init) {
1c001570:	e51b3008 	ldr	r3, [fp, #-8]
1c001574:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1c001578:	e3530000 	cmp	r3, #0
1c00157c:	0a00000c 	beq	1c0015b4 <ltzvisor_nsguest_create+0x1ac>
		memcpy((uint32_t *)g->gce_trd_load,(uint32_t *)g->gce_trd_start,(g->gce_trd_end - g->gce_trd_start));
1c001580:	e51b3008 	ldr	r3, [fp, #-8]
1c001584:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1c001588:	e1a00003 	mov	r0, r3
1c00158c:	e51b3008 	ldr	r3, [fp, #-8]
1c001590:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1c001594:	e1a01003 	mov	r1, r3
1c001598:	e51b3008 	ldr	r3, [fp, #-8]
1c00159c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1c0015a0:	e51b3008 	ldr	r3, [fp, #-8]
1c0015a4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1c0015a8:	e0423003 	sub	r3, r2, r3
1c0015ac:	e1a02003 	mov	r2, r3
1c0015b0:	ebfffc62 	bl	1c000740 <memcpy>
	}
	printk("      * NS_Guest load - OK  \n\t");
1c0015b4:	e30303d4 	movw	r0, #13268	; 0x33d4
1c0015b8:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0015bc:	ebffff4d 	bl	1c0012f8 <printk>

	/* Get NS_Guest ready to run */
	//cp15_restore(&NS_Guest.core.vcpu_regs_cp15);
	set_guest_context( (uint32_t)&NS_Guest);
1c0015c0:	e309383c 	movw	r3, #38972	; 0x983c
1c0015c4:	e3413c03 	movt	r3, #7171	; 0x1c03
1c0015c8:	e1a00003 	mov	r0, r3
1c0015cc:	ebfffc1b 	bl	1c000640 <set_guest_context>
	printk("      * NS_Guest ready to run - OK  \n\t");
1c0015d0:	e30303f4 	movw	r0, #13300	; 0x33f4
1c0015d4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0015d8:	ebffff46 	bl	1c0012f8 <printk>

	return TRUE;
1c0015dc:	e3a03001 	mov	r3, #1
}
1c0015e0:	e1a00003 	mov	r0, r3
1c0015e4:	e24bd004 	sub	sp, fp, #4
1c0015e8:	e8bd8800 	pop	{fp, pc}
1c0015ec:	1c039914 	.word	0x1c039914
1c0015f0:	1c0398b4 	.word	0x1c0398b4

1c0015f4 <ltzvisor_sguest_create>:

#ifndef CONFIG_COUPLED
uint32_t ltzvisor_sguest_create( struct guest_conf *g )
{
1c0015f4:	e92d4800 	push	{fp, lr}
1c0015f8:	e28db004 	add	fp, sp, #4
1c0015fc:	e24dd008 	sub	sp, sp, #8
1c001600:	e50b0008 	str	r0, [fp, #-8]

	_start = (void (*)(void)) g->gce_bin_load;
1c001604:	e51b3008 	ldr	r3, [fp, #-8]
1c001608:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1c00160c:	e1a02003 	mov	r2, r3
1c001610:	e3093838 	movw	r3, #38968	; 0x9838
1c001614:	e3413c03 	movt	r3, #7171	; 0x1c03
1c001618:	e5832000 	str	r2, [r3]

	/** Load Guest bin to Non-Secure Memory */
	printk("      * S_Guest loading ...  \n\t");
1c00161c:	e303041c 	movw	r0, #13340	; 0x341c
1c001620:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001624:	ebffff33 	bl	1c0012f8 <printk>
	printk("      * S_Guest gce_bin_load: 0x%x \n\t", g->gce_bin_load);
1c001628:	e51b3008 	ldr	r3, [fp, #-8]
1c00162c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1c001630:	e1a01003 	mov	r1, r3
1c001634:	e303043c 	movw	r0, #13372	; 0x343c
1c001638:	e3410c00 	movt	r0, #7168	; 0x1c00
1c00163c:	ebffff2d 	bl	1c0012f8 <printk>
	printk("      * S_Guest gce_bin_start: 0x%x \n\t", g->gce_bin_start);
1c001640:	e51b3008 	ldr	r3, [fp, #-8]
1c001644:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001648:	e1a01003 	mov	r1, r3
1c00164c:	e3030464 	movw	r0, #13412	; 0x3464
1c001650:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001654:	ebffff27 	bl	1c0012f8 <printk>
	printk("      * S_Guest gce_bin_end: 0x%x \n\t", g->gce_bin_end);
1c001658:	e51b3008 	ldr	r3, [fp, #-8]
1c00165c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1c001660:	e1a01003 	mov	r1, r3
1c001664:	e303048c 	movw	r0, #13452	; 0x348c
1c001668:	e3410c00 	movt	r0, #7168	; 0x1c00
1c00166c:	ebffff21 	bl	1c0012f8 <printk>
	memcpy((uint32_t *)g->gce_bin_load,(uint32_t *)g->gce_bin_start,(g->gce_bin_end - g->gce_bin_start));
1c001670:	e51b3008 	ldr	r3, [fp, #-8]
1c001674:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1c001678:	e1a00003 	mov	r0, r3
1c00167c:	e51b3008 	ldr	r3, [fp, #-8]
1c001680:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001684:	e1a01003 	mov	r1, r3
1c001688:	e51b3008 	ldr	r3, [fp, #-8]
1c00168c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
1c001690:	e51b3008 	ldr	r3, [fp, #-8]
1c001694:	e5933034 	ldr	r3, [r3, #52]	; 0x34
1c001698:	e0423003 	sub	r3, r2, r3
1c00169c:	e1a02003 	mov	r2, r3
1c0016a0:	ebfffc26 	bl	1c000740 <memcpy>
	if(g->gce_trd_init) {
1c0016a4:	e51b3008 	ldr	r3, [fp, #-8]
1c0016a8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1c0016ac:	e3530000 	cmp	r3, #0
1c0016b0:	0a00000c 	beq	1c0016e8 <ltzvisor_sguest_create+0xf4>
		memcpy((uint32_t *)g->gce_trd_load,(uint32_t *)g->gce_trd_start,(g->gce_trd_end - g->gce_trd_start));
1c0016b4:	e51b3008 	ldr	r3, [fp, #-8]
1c0016b8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1c0016bc:	e1a00003 	mov	r0, r3
1c0016c0:	e51b3008 	ldr	r3, [fp, #-8]
1c0016c4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1c0016c8:	e1a01003 	mov	r1, r3
1c0016cc:	e51b3008 	ldr	r3, [fp, #-8]
1c0016d0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1c0016d4:	e51b3008 	ldr	r3, [fp, #-8]
1c0016d8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1c0016dc:	e0423003 	sub	r3, r2, r3
1c0016e0:	e1a02003 	mov	r2, r3
1c0016e4:	ebfffc15 	bl	1c000740 <memcpy>
	}
	printk("      * NS_Guest load - OK  \n\t");
1c0016e8:	e30303d4 	movw	r0, #13268	; 0x33d4
1c0016ec:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0016f0:	ebffff00 	bl	1c0012f8 <printk>

	return TRUE;
1c0016f4:	e3a03001 	mov	r3, #1
}
1c0016f8:	e1a00003 	mov	r0, r3
1c0016fc:	e24bd004 	sub	sp, fp, #4
1c001700:	e8bd8800 	pop	{fp, pc}

1c001704 <ltzvisor_nsguest_restart>:
 *
 * @param  	g = pointer to guest configuration
 *
 * @retval 	TRUE if it is successful; FALSE if not!
 */
uint32_t ltzvisor_nsguest_restart( struct guest_conf *g ){
1c001704:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001708:	e28db000 	add	fp, sp, #0
1c00170c:	e24dd00c 	sub	sp, sp, #12
1c001710:	e50b0008 	str	r0, [fp, #-8]

	/** TODO - Implement restart of NS_Guest */
	while(1);
1c001714:	eafffffe 	b	1c001714 <ltzvisor_nsguest_restart+0x10>

1c001718 <ltzvisor_main>:
 *
 * @param  	
 *
 * @retval 	
 */
void ltzvisor_main(void){
1c001718:	e92d4800 	push	{fp, lr}
1c00171c:	e28db004 	add	fp, sp, #4
1c001720:	e24dd008 	sub	sp, sp, #8
	uint32_t ret;

	/** Initialize LTZVisor */
	ret = ltzvisor_init();
1c001724:	ebffff1f 	bl	1c0013a8 <ltzvisor_init>
1c001728:	e50b0008 	str	r0, [fp, #-8]
	if(!ret){
1c00172c:	e51b3008 	ldr	r3, [fp, #-8]
1c001730:	e3530000 	cmp	r3, #0
1c001734:	1a000003 	bne	1c001748 <ltzvisor_main+0x30>
		/* ERROR */
		printk("ERROR: LTZVisor Init ... \n\t");
1c001738:	e30304b4 	movw	r0, #13492	; 0x34b4
1c00173c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001740:	ebfffeec 	bl	1c0012f8 <printk>
		while(1);
1c001744:	eafffffe 	b	1c001744 <ltzvisor_main+0x2c>
	}

	/** Create NS_Guest (Linux) */
	printk(" -> Guests: NS_Guest creation ... \n\t", ARCH);
1c001748:	e30314d0 	movw	r1, #13520	; 0x34d0
1c00174c:	e3411c00 	movt	r1, #7168	; 0x1c00
1c001750:	e30304d8 	movw	r0, #13528	; 0x34d8
1c001754:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001758:	ebfffee6 	bl	1c0012f8 <printk>
	ret = ltzvisor_nsguest_create( &nsguest_config );
1c00175c:	e30301a0 	movw	r0, #12704	; 0x31a0
1c001760:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001764:	ebffff27 	bl	1c001408 <ltzvisor_nsguest_create>
1c001768:	e50b0008 	str	r0, [fp, #-8]
	if(!ret){
1c00176c:	e51b3008 	ldr	r3, [fp, #-8]
1c001770:	e3530000 	cmp	r3, #0
1c001774:	1a000003 	bne	1c001788 <ltzvisor_main+0x70>
		/* ERROR */
		printk("Error: LTZVisor NS_Guest Create\n\t");
1c001778:	e3030500 	movw	r0, #13568	; 0x3500
1c00177c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001780:	ebfffedc 	bl	1c0012f8 <printk>
		while(1);
1c001784:	eafffffe 	b	1c001784 <ltzvisor_main+0x6c>
	}

#ifndef CONFIG_COUPLED
	ltzvisor_sguest_create(&sguest_config);
1c001788:	e30301e0 	movw	r0, #12768	; 0x31e0
1c00178c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c001790:	ebffff97 	bl	1c0015f4 <ltzvisor_sguest_create>
#endif

	cachel2_init();
1c001794:	eb00056b 	bl	1c002d48 <cachel2_init>

	/** Kick off LTZVisor and start running Guests */
	printk(" -> LTZVisor: kicking off ... \n\t", ARCH);
1c001798:	e30314d0 	movw	r1, #13520	; 0x34d0
1c00179c:	e3411c00 	movt	r1, #7168	; 0x1c00
1c0017a0:	e3030524 	movw	r0, #13604	; 0x3524
1c0017a4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0017a8:	ebfffed2 	bl	1c0012f8 <printk>
	printk(" -> LTZVisor: starting S_Guest ... \n\t", ARCH);
1c0017ac:	e30314d0 	movw	r1, #13520	; 0x34d0
1c0017b0:	e3411c00 	movt	r1, #7168	; 0x1c00
1c0017b4:	e3030548 	movw	r0, #13640	; 0x3548
1c0017b8:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0017bc:	ebfffecd 	bl	1c0012f8 <printk>
	printk("----------------------------------------------------------\n\n\t");
1c0017c0:	e3030570 	movw	r0, #13680	; 0x3570
1c0017c4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0017c8:	ebfffeca 	bl	1c0012f8 <printk>
	ltzvisor_kickoff();
1c0017cc:	ebfffefe 	bl	1c0013cc <ltzvisor_kickoff>

	/** This point should never be reached */
	while (1);
1c0017d0:	eafffffe 	b	1c0017d0 <ltzvisor_main+0xb8>

1c0017d4 <fiq_handler>:
	NULL, 
	NULL
};

/* TODO - This is exception handling */
void fiq_handler(uint32_t interrupt){
1c0017d4:	e92d4800 	push	{fp, lr}
1c0017d8:	e28db004 	add	fp, sp, #4
1c0017dc:	e24dd008 	sub	sp, sp, #8
1c0017e0:	e50b0008 	str	r0, [fp, #-8]
	if (fiq_handlers[interrupt])
1c0017e4:	e303301c 	movw	r3, #12316	; 0x301c
1c0017e8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0017ec:	e51b2008 	ldr	r2, [fp, #-8]
1c0017f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0017f4:	e3530000 	cmp	r3, #0
1c0017f8:	0a000006 	beq	1c001818 <fiq_handler+0x44>
		fiq_handlers[interrupt]((void *) interrupt);
1c0017fc:	e303301c 	movw	r3, #12316	; 0x301c
1c001800:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001804:	e51b2008 	ldr	r2, [fp, #-8]
1c001808:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c00180c:	e51b2008 	ldr	r2, [fp, #-8]
1c001810:	e1a00002 	mov	r0, r2
1c001814:	e12fff33 	blx	r3
}
1c001818:	e320f000 	nop	{0}
1c00181c:	e24bd004 	sub	sp, fp, #4
1c001820:	e8bd8800 	pop	{fp, pc}

1c001824 <interrupt_distributor_init>:
 *
 * @param  	
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t interrupt_distributor_init(void){
1c001824:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001828:	e28db000 	add	fp, sp, #0
1c00182c:	e24dd00c 	sub	sp, sp, #12

	uint32_t i;

	/** Check the ARM Legacy Identification Register Field values */
	if (int_dist->ICPIDR_0_3[0] != 0x90 || int_dist->ICPIDR_0_3[1] != 0xB3 ||
1c001830:	e3033018 	movw	r3, #12312	; 0x3018
1c001834:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001838:	e5933000 	ldr	r3, [r3]
1c00183c:	e5933fe0 	ldr	r3, [r3, #4064]	; 0xfe0
1c001840:	e3530090 	cmp	r3, #144	; 0x90
1c001844:	1a000041 	bne	1c001950 <interrupt_distributor_init+0x12c>
1c001848:	e3033018 	movw	r3, #12312	; 0x3018
1c00184c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001850:	e5933000 	ldr	r3, [r3]
1c001854:	e5933fe4 	ldr	r3, [r3, #4068]	; 0xfe4
1c001858:	e35300b3 	cmp	r3, #179	; 0xb3
1c00185c:	1a00003b 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_0_3[2] != 0x1B || int_dist->ICPIDR_0_3[3] != 0x00 ||
1c001860:	e3033018 	movw	r3, #12312	; 0x3018
1c001864:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001868:	e5933000 	ldr	r3, [r3]
1c00186c:	e5933fe8 	ldr	r3, [r3, #4072]	; 0xfe8
	if (int_dist->ICPIDR_0_3[0] != 0x90 || int_dist->ICPIDR_0_3[1] != 0xB3 ||
1c001870:	e353001b 	cmp	r3, #27
1c001874:	1a000035 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_0_3[2] != 0x1B || int_dist->ICPIDR_0_3[3] != 0x00 ||
1c001878:	e3033018 	movw	r3, #12312	; 0x3018
1c00187c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001880:	e5933000 	ldr	r3, [r3]
1c001884:	e5933fec 	ldr	r3, [r3, #4076]	; 0xfec
1c001888:	e3530000 	cmp	r3, #0
1c00188c:	1a00002f 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_4_7[0] != 0x04 || int_dist->ICPIDR_4_7[1] != 0x00 ||
1c001890:	e3033018 	movw	r3, #12312	; 0x3018
1c001894:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001898:	e5933000 	ldr	r3, [r3]
1c00189c:	e5933fd0 	ldr	r3, [r3, #4048]	; 0xfd0
	    int_dist->ICPIDR_0_3[2] != 0x1B || int_dist->ICPIDR_0_3[3] != 0x00 ||
1c0018a0:	e3530004 	cmp	r3, #4
1c0018a4:	1a000029 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_4_7[0] != 0x04 || int_dist->ICPIDR_4_7[1] != 0x00 ||
1c0018a8:	e3033018 	movw	r3, #12312	; 0x3018
1c0018ac:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0018b0:	e5933000 	ldr	r3, [r3]
1c0018b4:	e5933fd4 	ldr	r3, [r3, #4052]	; 0xfd4
1c0018b8:	e3530000 	cmp	r3, #0
1c0018bc:	1a000023 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_4_7[2] != 0x00 || int_dist->ICPIDR_4_7[3] != 0x00 ||
1c0018c0:	e3033018 	movw	r3, #12312	; 0x3018
1c0018c4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0018c8:	e5933000 	ldr	r3, [r3]
1c0018cc:	e5933fd8 	ldr	r3, [r3, #4056]	; 0xfd8
	    int_dist->ICPIDR_4_7[0] != 0x04 || int_dist->ICPIDR_4_7[1] != 0x00 ||
1c0018d0:	e3530000 	cmp	r3, #0
1c0018d4:	1a00001d 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICPIDR_4_7[2] != 0x00 || int_dist->ICPIDR_4_7[3] != 0x00 ||
1c0018d8:	e3033018 	movw	r3, #12312	; 0x3018
1c0018dc:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0018e0:	e5933000 	ldr	r3, [r3]
1c0018e4:	e5933fdc 	ldr	r3, [r3, #4060]	; 0xfdc
1c0018e8:	e3530000 	cmp	r3, #0
1c0018ec:	1a000017 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICCIDRx[0] != 0x0D || int_dist->ICCIDRx[1] != 0xF0 ||
1c0018f0:	e3033018 	movw	r3, #12312	; 0x3018
1c0018f4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0018f8:	e5933000 	ldr	r3, [r3]
1c0018fc:	e5933ff0 	ldr	r3, [r3, #4080]	; 0xff0
	    int_dist->ICPIDR_4_7[2] != 0x00 || int_dist->ICPIDR_4_7[3] != 0x00 ||
1c001900:	e353000d 	cmp	r3, #13
1c001904:	1a000011 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICCIDRx[0] != 0x0D || int_dist->ICCIDRx[1] != 0xF0 ||
1c001908:	e3033018 	movw	r3, #12312	; 0x3018
1c00190c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001910:	e5933000 	ldr	r3, [r3]
1c001914:	e5933ff4 	ldr	r3, [r3, #4084]	; 0xff4
1c001918:	e35300f0 	cmp	r3, #240	; 0xf0
1c00191c:	1a00000b 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICCIDRx[2] != 0x05 || int_dist->ICCIDRx[3] != 0xB1){
1c001920:	e3033018 	movw	r3, #12312	; 0x3018
1c001924:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001928:	e5933000 	ldr	r3, [r3]
1c00192c:	e5933ff8 	ldr	r3, [r3, #4088]	; 0xff8
	    int_dist->ICCIDRx[0] != 0x0D || int_dist->ICCIDRx[1] != 0xF0 ||
1c001930:	e3530005 	cmp	r3, #5
1c001934:	1a000005 	bne	1c001950 <interrupt_distributor_init+0x12c>
	    int_dist->ICCIDRx[2] != 0x05 || int_dist->ICCIDRx[3] != 0xB1){
1c001938:	e3033018 	movw	r3, #12312	; 0x3018
1c00193c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001940:	e5933000 	ldr	r3, [r3]
1c001944:	e5933ffc 	ldr	r3, [r3, #4092]	; 0xffc
1c001948:	e35300b1 	cmp	r3, #177	; 0xb1
1c00194c:	0a000001 	beq	1c001958 <interrupt_distributor_init+0x134>

		return FALSE;
1c001950:	e3a03000 	mov	r3, #0
1c001954:	ea00005b 	b	1c001ac8 <interrupt_distributor_init+0x2a4>
	}

	/** Disable the whole controller (S and NS) */
	int_dist->ICDDCR = 0x00000000;
1c001958:	e3033018 	movw	r3, #12312	; 0x3018
1c00195c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001960:	e5933000 	ldr	r3, [r3]
1c001964:	e3a02000 	mov	r2, #0
1c001968:	e5832000 	str	r2, [r3]

	/** Disable all interrupts */
	for (i = 0; i < GIC_NUM_REGISTERS; i++){
1c00196c:	e3a03000 	mov	r3, #0
1c001970:	e50b3008 	str	r3, [fp, #-8]
1c001974:	ea000009 	b	1c0019a0 <interrupt_distributor_init+0x17c>
		/* Clear-Enable */
		int_dist->ICDICERx[i] = 0xFFFFFFFF;	
1c001978:	e3033018 	movw	r3, #12312	; 0x3018
1c00197c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001980:	e5933000 	ldr	r3, [r3]
1c001984:	e51b2008 	ldr	r2, [fp, #-8]
1c001988:	e2822060 	add	r2, r2, #96	; 0x60
1c00198c:	e3e01000 	mvn	r1, #0
1c001990:	e7831102 	str	r1, [r3, r2, lsl #2]
	for (i = 0; i < GIC_NUM_REGISTERS; i++){
1c001994:	e51b3008 	ldr	r3, [fp, #-8]
1c001998:	e2833001 	add	r3, r3, #1
1c00199c:	e50b3008 	str	r3, [fp, #-8]
1c0019a0:	e51b3008 	ldr	r3, [fp, #-8]
1c0019a4:	e3530002 	cmp	r3, #2
1c0019a8:	9afffff2 	bls	1c001978 <interrupt_distributor_init+0x154>
	}

	/** Clear all SPI interrupts */
	for (i = 1; i < GIC_NUM_REGISTERS; i++){
1c0019ac:	e3a03001 	mov	r3, #1
1c0019b0:	e50b3008 	str	r3, [fp, #-8]
1c0019b4:	ea000009 	b	1c0019e0 <interrupt_distributor_init+0x1bc>
		/* Clear-Pending */
		int_dist->ICDICPRx[i] = 0xFFFFFFFF;	
1c0019b8:	e3033018 	movw	r3, #12312	; 0x3018
1c0019bc:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0019c0:	e5933000 	ldr	r3, [r3]
1c0019c4:	e51b2008 	ldr	r2, [fp, #-8]
1c0019c8:	e28220a0 	add	r2, r2, #160	; 0xa0
1c0019cc:	e3e01000 	mvn	r1, #0
1c0019d0:	e7831102 	str	r1, [r3, r2, lsl #2]
	for (i = 1; i < GIC_NUM_REGISTERS; i++){
1c0019d4:	e51b3008 	ldr	r3, [fp, #-8]
1c0019d8:	e2833001 	add	r3, r3, #1
1c0019dc:	e50b3008 	str	r3, [fp, #-8]
1c0019e0:	e51b3008 	ldr	r3, [fp, #-8]
1c0019e4:	e3530002 	cmp	r3, #2
1c0019e8:	9afffff2 	bls	1c0019b8 <interrupt_distributor_init+0x194>
	}

	/** Reset SPI interrupt priorities */
	for (i = 8; i < GIC_PRIORITY_REGISTERS; i++){
1c0019ec:	e3a03008 	mov	r3, #8
1c0019f0:	e50b3008 	str	r3, [fp, #-8]
1c0019f4:	ea000009 	b	1c001a20 <interrupt_distributor_init+0x1fc>

		int_dist->ICDIPRx[i] = 0x00000000;
1c0019f8:	e3033018 	movw	r3, #12312	; 0x3018
1c0019fc:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001a00:	e5933000 	ldr	r3, [r3]
1c001a04:	e51b2008 	ldr	r2, [fp, #-8]
1c001a08:	e2822c01 	add	r2, r2, #256	; 0x100
1c001a0c:	e3a01000 	mov	r1, #0
1c001a10:	e7831102 	str	r1, [r3, r2, lsl #2]
	for (i = 8; i < GIC_PRIORITY_REGISTERS; i++){
1c001a14:	e51b3008 	ldr	r3, [fp, #-8]
1c001a18:	e2833001 	add	r3, r3, #1
1c001a1c:	e50b3008 	str	r3, [fp, #-8]
1c001a20:	e51b3008 	ldr	r3, [fp, #-8]
1c001a24:	e3530017 	cmp	r3, #23
1c001a28:	9afffff2 	bls	1c0019f8 <interrupt_distributor_init+0x1d4>
	}

	/** Reset interrupt targets */
	for (i = 0; i < GIC_TARGET_REGISTERS; i++){
1c001a2c:	e3a03000 	mov	r3, #0
1c001a30:	e50b3008 	str	r3, [fp, #-8]
1c001a34:	ea000009 	b	1c001a60 <interrupt_distributor_init+0x23c>

		int_dist->ICDIPTRx[i] = 0x00000000;
1c001a38:	e3033018 	movw	r3, #12312	; 0x3018
1c001a3c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001a40:	e5933000 	ldr	r3, [r3]
1c001a44:	e51b2008 	ldr	r2, [fp, #-8]
1c001a48:	e2822c02 	add	r2, r2, #512	; 0x200
1c001a4c:	e3a01000 	mov	r1, #0
1c001a50:	e7831102 	str	r1, [r3, r2, lsl #2]
	for (i = 0; i < GIC_TARGET_REGISTERS; i++){
1c001a54:	e51b3008 	ldr	r3, [fp, #-8]
1c001a58:	e2833001 	add	r3, r3, #1
1c001a5c:	e50b3008 	str	r3, [fp, #-8]
1c001a60:	e51b3008 	ldr	r3, [fp, #-8]
1c001a64:	e3530017 	cmp	r3, #23
1c001a68:	9afffff2 	bls	1c001a38 <interrupt_distributor_init+0x214>
	}

	/** Set interrupt configuration (level high sensitive, 1-N) */
	for (i = 2; i < (NO_OF_INTERRUPTS_IMPLEMENTED - 32) / 16; i++){
1c001a6c:	e3a03002 	mov	r3, #2
1c001a70:	e50b3008 	str	r3, [fp, #-8]
1c001a74:	ea00000a 	b	1c001aa4 <interrupt_distributor_init+0x280>

		int_dist->ICDICFRx[i] = 0x55555555;
1c001a78:	e3033018 	movw	r3, #12312	; 0x3018
1c001a7c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001a80:	e5932000 	ldr	r2, [r3]
1c001a84:	e51b3008 	ldr	r3, [fp, #-8]
1c001a88:	e2831c03 	add	r1, r3, #768	; 0x300
1c001a8c:	e3053555 	movw	r3, #21845	; 0x5555
1c001a90:	e3453555 	movt	r3, #21845	; 0x5555
1c001a94:	e7823101 	str	r3, [r2, r1, lsl #2]
	for (i = 2; i < (NO_OF_INTERRUPTS_IMPLEMENTED - 32) / 16; i++){
1c001a98:	e51b3008 	ldr	r3, [fp, #-8]
1c001a9c:	e2833001 	add	r3, r3, #1
1c001aa0:	e50b3008 	str	r3, [fp, #-8]
1c001aa4:	e51b3008 	ldr	r3, [fp, #-8]
1c001aa8:	e3530003 	cmp	r3, #3
1c001aac:	9afffff1 	bls	1c001a78 <interrupt_distributor_init+0x254>
	}

	/** Enable the interrupt controller (group0 and group1) */
	int_dist->ICDDCR = 0x00000003;
1c001ab0:	e3033018 	movw	r3, #12312	; 0x3018
1c001ab4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001ab8:	e5933000 	ldr	r3, [r3]
1c001abc:	e3a02003 	mov	r2, #3
1c001ac0:	e5832000 	str	r2, [r3]

	return TRUE;
1c001ac4:	e3a03001 	mov	r3, #1
}
1c001ac8:	e1a00003 	mov	r0, r3
1c001acc:	e24bd000 	sub	sp, fp, #0
1c001ad0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001ad4:	e12fff1e 	bx	lr

1c001ad8 <interrupt_interface_init>:
 *
 * @param  	
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t interrupt_interface_init(void){
1c001ad8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001adc:	e28db000 	add	fp, sp, #0
1c001ae0:	e24dd00c 	sub	sp, sp, #12

	uint32_t i;

	/** Clear the bits of the distributor which are CPU-specific */
	/* Clear-Pending */
	int_dist->ICDICPRx[0] = 0xFFFFFFFF;			
1c001ae4:	e3033018 	movw	r3, #12312	; 0x3018
1c001ae8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001aec:	e5933000 	ldr	r3, [r3]
1c001af0:	e3e02000 	mvn	r2, #0
1c001af4:	e5832280 	str	r2, [r3, #640]	; 0x280
	for (i = 0; i < 8; i++){
1c001af8:	e3a03000 	mov	r3, #0
1c001afc:	e50b3008 	str	r3, [fp, #-8]
1c001b00:	ea000009 	b	1c001b2c <interrupt_interface_init+0x54>
		/* SGI and PPI interrupt priorities */
		int_dist->ICDIPRx[i] = 0x00000000;
1c001b04:	e3033018 	movw	r3, #12312	; 0x3018
1c001b08:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001b0c:	e5933000 	ldr	r3, [r3]
1c001b10:	e51b2008 	ldr	r2, [fp, #-8]
1c001b14:	e2822c01 	add	r2, r2, #256	; 0x100
1c001b18:	e3a01000 	mov	r1, #0
1c001b1c:	e7831102 	str	r1, [r3, r2, lsl #2]
	for (i = 0; i < 8; i++){
1c001b20:	e51b3008 	ldr	r3, [fp, #-8]
1c001b24:	e2833001 	add	r3, r3, #1
1c001b28:	e50b3008 	str	r3, [fp, #-8]
1c001b2c:	e51b3008 	ldr	r3, [fp, #-8]
1c001b30:	e3530007 	cmp	r3, #7
1c001b34:	9afffff2 	bls	1c001b04 <interrupt_interface_init+0x2c>
	}
	/* SGI and PPI set interrupt configuration */
	int_dist->ICDICFRx[0] = 0xAAAAAAAA;
1c001b38:	e3033018 	movw	r3, #12312	; 0x3018
1c001b3c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001b40:	e5932000 	ldr	r2, [r3]
1c001b44:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
1c001b48:	e34a3aaa 	movt	r3, #43690	; 0xaaaa
1c001b4c:	e5823c00 	str	r3, [r2, #3072]	; 0xc00
	int_dist->ICDICFRx[1] = 0xAAAAAAAA;
1c001b50:	e3033018 	movw	r3, #12312	; 0x3018
1c001b54:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001b58:	e5932000 	ldr	r2, [r3]
1c001b5c:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
1c001b60:	e34a3aaa 	movt	r3, #43690	; 0xaaaa
1c001b64:	e5823c04 	str	r3, [r2, #3076]	; 0xc04

	/** Disable CPU Interface */
	cpu_inter->ICCICR = 0x00000000;
1c001b68:	e3a03c01 	mov	r3, #256	; 0x100
1c001b6c:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001b70:	e3a02000 	mov	r2, #0
1c001b74:	e5832000 	str	r2, [r3]

	/** Allow interrupts with higher priority (i.e. lower number) than 0xF */
	cpu_inter->ICCPMR = 0x000000F0;
1c001b78:	e3a03c01 	mov	r3, #256	; 0x100
1c001b7c:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001b80:	e3a020f0 	mov	r2, #240	; 0xf0
1c001b84:	e5832004 	str	r2, [r3, #4]

	/** All priority bits are compared for pre-emption */
	cpu_inter->ICCBPR = 0x00000002;	
1c001b88:	e3a03c01 	mov	r3, #256	; 0x100
1c001b8c:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001b90:	e3a02002 	mov	r2, #2
1c001b94:	e5832008 	str	r2, [r3, #8]
	/** Clear any pending interrupts */
	for( ; ; ){

		uint32_t temp;
		/* interrupt_ack */
		temp = cpu_inter->ICCIAR;			
1c001b98:	e3a03c01 	mov	r3, #256	; 0x100
1c001b9c:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001ba0:	e593300c 	ldr	r3, [r3, #12]
1c001ba4:	e50b300c 	str	r3, [fp, #-12]

		if((temp & GIC_ACK_INTID_MASK) == FAKE_INTERRUPT)
1c001ba8:	e51b300c 	ldr	r3, [fp, #-12]
1c001bac:	e7e93053 	ubfx	r3, r3, #0, #10
1c001bb0:	e30023ff 	movw	r2, #1023	; 0x3ff
1c001bb4:	e1530002 	cmp	r3, r2
1c001bb8:	0a000004 	beq	1c001bd0 <interrupt_interface_init+0xf8>
		{
			break;
		}
		/* end_of_interrupt */
		cpu_inter->ICCEOIR = temp;			
1c001bbc:	e3a03c01 	mov	r3, #256	; 0x100
1c001bc0:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001bc4:	e51b200c 	ldr	r2, [fp, #-12]
1c001bc8:	e5832010 	str	r2, [r3, #16]
	for( ; ; ){
1c001bcc:	eafffff1 	b	1c001b98 <interrupt_interface_init+0xc0>
			break;
1c001bd0:	e320f000 	nop	{0}
	}

	/** Enable the CPU Interface */
	cpu_inter->ICCICR = 0x00000009;	
1c001bd4:	e3a03c01 	mov	r3, #256	; 0x100
1c001bd8:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001bdc:	e3a02009 	mov	r2, #9
1c001be0:	e5832000 	str	r2, [r3]

	return TRUE;
1c001be4:	e3a03001 	mov	r3, #1
}
1c001be8:	e1a00003 	mov	r0, r3
1c001bec:	e24bd000 	sub	sp, fp, #0
1c001bf0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001bf4:	e12fff1e 	bx	lr

1c001bf8 <interrupt_enable>:
 * @param	interrupt = interrupt number
 *		enable = set (enable=1) or clear (enable=0)   	
 *
 * @retval	 	
 */
void interrupt_enable(uint32_t interrupt, uint32_t enable){
1c001bf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001bfc:	e28db000 	add	fp, sp, #0
1c001c00:	e24dd014 	sub	sp, sp, #20
1c001c04:	e50b0010 	str	r0, [fp, #-16]
1c001c08:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

	uint32_t word;

	/** Calculate interrupt position */
	word = interrupt / 32;
1c001c0c:	e51b3010 	ldr	r3, [fp, #-16]
1c001c10:	e1a032a3 	lsr	r3, r3, #5
1c001c14:	e50b3008 	str	r3, [fp, #-8]
	interrupt %= 32;
1c001c18:	e51b3010 	ldr	r3, [fp, #-16]
1c001c1c:	e203301f 	and	r3, r3, #31
1c001c20:	e50b3010 	str	r3, [fp, #-16]
	interrupt = 1 << interrupt;
1c001c24:	e3a02001 	mov	r2, #1
1c001c28:	e51b3010 	ldr	r3, [fp, #-16]
1c001c2c:	e1a03312 	lsl	r3, r2, r3
1c001c30:	e50b3010 	str	r3, [fp, #-16]

	if (enable){
1c001c34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c001c38:	e3530000 	cmp	r3, #0
1c001c3c:	0a000007 	beq	1c001c60 <interrupt_enable+0x68>
		/* Set */
		int_dist->ICDISERx[word] = interrupt;
1c001c40:	e3033018 	movw	r3, #12312	; 0x3018
1c001c44:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001c48:	e5933000 	ldr	r3, [r3]
1c001c4c:	e51b2008 	ldr	r2, [fp, #-8]
1c001c50:	e2822040 	add	r2, r2, #64	; 0x40
1c001c54:	e51b1010 	ldr	r1, [fp, #-16]
1c001c58:	e7831102 	str	r1, [r3, r2, lsl #2]
	}
	else{
		/* Clear */
		int_dist->ICDICERx[word] = interrupt;
	}
}
1c001c5c:	ea000006 	b	1c001c7c <interrupt_enable+0x84>
		int_dist->ICDICERx[word] = interrupt;
1c001c60:	e3033018 	movw	r3, #12312	; 0x3018
1c001c64:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001c68:	e5933000 	ldr	r3, [r3]
1c001c6c:	e51b2008 	ldr	r2, [fp, #-8]
1c001c70:	e2822060 	add	r2, r2, #96	; 0x60
1c001c74:	e51b1010 	ldr	r1, [fp, #-16]
1c001c78:	e7831102 	str	r1, [r3, r2, lsl #2]
}
1c001c7c:	e320f000 	nop	{0}
1c001c80:	e24bd000 	sub	sp, fp, #0
1c001c84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001c88:	e12fff1e 	bx	lr

1c001c8c <interrupt_priority_set>:
 * @param	interrupt = interrupt number
 *		priority = priority value   	
 *
 * @retval	Return original priority	 	
 */
uint32_t interrupt_priority_set(uint32_t interrupt, uint32_t priority){
1c001c8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001c90:	e28db000 	add	fp, sp, #0
1c001c94:	e24dd01c 	sub	sp, sp, #28
1c001c98:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
1c001c9c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4

	uint32_t word, bit_shift, temp, old_priority;

	priority &= 0xF;
1c001ca0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c001ca4:	e203300f 	and	r3, r3, #15
1c001ca8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
	/* Get register of interrupt */
	word = interrupt / 4; 					
1c001cac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c001cb0:	e1a03123 	lsr	r3, r3, #2
1c001cb4:	e50b3008 	str	r3, [fp, #-8]
	bit_shift = (interrupt % 4) * 8 + 4; 			
1c001cb8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c001cbc:	e2033003 	and	r3, r3, #3
1c001cc0:	e1a03183 	lsl	r3, r3, #3
1c001cc4:	e2833004 	add	r3, r3, #4
1c001cc8:	e50b300c 	str	r3, [fp, #-12]

	/* Get priority register */
	temp = old_priority = int_dist->ICDIPRx[word]; 		
1c001ccc:	e3033018 	movw	r3, #12312	; 0x3018
1c001cd0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001cd4:	e5933000 	ldr	r3, [r3]
1c001cd8:	e51b2008 	ldr	r2, [fp, #-8]
1c001cdc:	e2822c01 	add	r2, r2, #256	; 0x100
1c001ce0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c001ce4:	e50b3010 	str	r3, [fp, #-16]
1c001ce8:	e51b3010 	ldr	r3, [fp, #-16]
1c001cec:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	/* Reset the priority for this interrupt to 0 */
	temp &= ~((uint32_t)0xF << bit_shift); 			
1c001cf0:	e3a0200f 	mov	r2, #15
1c001cf4:	e51b300c 	ldr	r3, [fp, #-12]
1c001cf8:	e1a03312 	lsl	r3, r2, r3
1c001cfc:	e1e03003 	mvn	r3, r3
1c001d00:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c001d04:	e0033002 	and	r3, r3, r2
1c001d08:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	/* Set the new priority */
	temp |= (priority << bit_shift); 			
1c001d0c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c001d10:	e51b300c 	ldr	r3, [fp, #-12]
1c001d14:	e1a03312 	lsl	r3, r2, r3
1c001d18:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c001d1c:	e1823003 	orr	r3, r2, r3
1c001d20:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	int_dist->ICDIPRx[word] = temp; 			
1c001d24:	e3033018 	movw	r3, #12312	; 0x3018
1c001d28:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001d2c:	e5933000 	ldr	r3, [r3]
1c001d30:	e51b2008 	ldr	r2, [fp, #-8]
1c001d34:	e2822c01 	add	r2, r2, #256	; 0x100
1c001d38:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
1c001d3c:	e7831102 	str	r1, [r3, r2, lsl #2]

	return ((old_priority >> bit_shift) & 0xF); 		
1c001d40:	e51b2010 	ldr	r2, [fp, #-16]
1c001d44:	e51b300c 	ldr	r3, [fp, #-12]
1c001d48:	e1a03332 	lsr	r3, r2, r3
1c001d4c:	e203300f 	and	r3, r3, #15
}
1c001d50:	e1a00003 	mov	r0, r3
1c001d54:	e24bd000 	sub	sp, fp, #0
1c001d58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001d5c:	e12fff1e 	bx	lr

1c001d60 <interrupt_target_set>:
 *		cpu = target cpu id 
 *		set = set value  	
 *
 * @retval	 	
 */
void interrupt_target_set(uint32_t interrupt, uint32_t cpu, uint32_t set){
1c001d60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001d64:	e28db000 	add	fp, sp, #0
1c001d68:	e24dd024 	sub	sp, sp, #36	; 0x24
1c001d6c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
1c001d70:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
1c001d74:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0

	uint32_t word, bit_shift, temp;

	/* Get register of interrupt */
	word = interrupt / 4;
1c001d78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c001d7c:	e1a03123 	lsr	r3, r3, #2
1c001d80:	e50b300c 	str	r3, [fp, #-12]
	bit_shift = (interrupt % 4) * 8;
1c001d84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c001d88:	e2033003 	and	r3, r3, #3
1c001d8c:	e1a03183 	lsl	r3, r3, #3
1c001d90:	e50b3010 	str	r3, [fp, #-16]
	cpu = (1 << cpu) << bit_shift;
1c001d94:	e3a02001 	mov	r2, #1
1c001d98:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c001d9c:	e1a02312 	lsl	r2, r2, r3
1c001da0:	e51b3010 	ldr	r3, [fp, #-16]
1c001da4:	e1a03312 	lsl	r3, r2, r3
1c001da8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	temp = int_dist->ICDIPTRx[word];
1c001dac:	e3033018 	movw	r3, #12312	; 0x3018
1c001db0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001db4:	e5933000 	ldr	r3, [r3]
1c001db8:	e51b200c 	ldr	r2, [fp, #-12]
1c001dbc:	e2822c02 	add	r2, r2, #512	; 0x200
1c001dc0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c001dc4:	e50b3008 	str	r3, [fp, #-8]
	if (set){
1c001dc8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c001dcc:	e3530000 	cmp	r3, #0
1c001dd0:	0a000004 	beq	1c001de8 <interrupt_target_set+0x88>
		/* Set */
		temp |= cpu;
1c001dd4:	e51b2008 	ldr	r2, [fp, #-8]
1c001dd8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c001ddc:	e1823003 	orr	r3, r2, r3
1c001de0:	e50b3008 	str	r3, [fp, #-8]
1c001de4:	ea000004 	b	1c001dfc <interrupt_target_set+0x9c>
	}
	else{
		/* Clear */
		temp &= ~cpu;
1c001de8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c001dec:	e1e03003 	mvn	r3, r3
1c001df0:	e51b2008 	ldr	r2, [fp, #-8]
1c001df4:	e0033002 	and	r3, r3, r2
1c001df8:	e50b3008 	str	r3, [fp, #-8]
	}
	int_dist->ICDIPTRx[word] = temp;
1c001dfc:	e3033018 	movw	r3, #12312	; 0x3018
1c001e00:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001e04:	e5933000 	ldr	r3, [r3]
1c001e08:	e51b200c 	ldr	r2, [fp, #-12]
1c001e0c:	e2822c02 	add	r2, r2, #512	; 0x200
1c001e10:	e51b1008 	ldr	r1, [fp, #-8]
1c001e14:	e7831102 	str	r1, [r3, r2, lsl #2]
}
1c001e18:	e320f000 	nop	{0}
1c001e1c:	e24bd000 	sub	sp, fp, #0
1c001e20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001e24:	e12fff1e 	bx	lr

1c001e28 <interrupt_clear>:
 * @param	interrupt = interrupt number
 *		target =  	
 *
 * @retval	 	
 */
void interrupt_clear(uint32_t interrupt, uint32_t target){
1c001e28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001e2c:	e28db000 	add	fp, sp, #0
1c001e30:	e24dd00c 	sub	sp, sp, #12
1c001e34:	e50b0008 	str	r0, [fp, #-8]
1c001e38:	e50b100c 	str	r1, [fp, #-12]

	/* Clear interrupt */
	cpu_inter->ICCEOIR = ( target << 10) | interrupt;
1c001e3c:	e3a03c01 	mov	r3, #256	; 0x100
1c001e40:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001e44:	e51b200c 	ldr	r2, [fp, #-12]
1c001e48:	e1a01502 	lsl	r1, r2, #10
1c001e4c:	e51b2008 	ldr	r2, [fp, #-8]
1c001e50:	e1812002 	orr	r2, r1, r2
1c001e54:	e5832010 	str	r2, [r3, #16]

}
1c001e58:	e320f000 	nop	{0}
1c001e5c:	e24bd000 	sub	sp, fp, #0
1c001e60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001e64:	e12fff1e 	bx	lr

1c001e68 <interrupt_acknowledge>:
 * @param
 *
 * @retval
 * 		read value
 */
uint32_t interrupt_acknowledge(){
1c001e68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001e6c:	e28db000 	add	fp, sp, #0
	return cpu_inter->ICCIAR;
1c001e70:	e3a03c01 	mov	r3, #256	; 0x100
1c001e74:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001e78:	e593300c 	ldr	r3, [r3, #12]
}
1c001e7c:	e1a00003 	mov	r0, r3
1c001e80:	e24bd000 	sub	sp, fp, #0
1c001e84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001e88:	e12fff1e 	bx	lr

1c001e8c <interrupt_security_configall>:
 *
 * @param	
 *
 * @retval	 	
 */
void interrupt_security_configall(void){
1c001e8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001e90:	e28db000 	add	fp, sp, #0
1c001e94:	e24dd00c 	sub	sp, sp, #12

	uint32_t num_regs;
	/* Configure all global interrupts as NS Interrupts */
	for(num_regs=0; num_regs < GIC_NUM_REGISTERS; num_regs++){
1c001e98:	e3a03000 	mov	r3, #0
1c001e9c:	e50b3008 	str	r3, [fp, #-8]
1c001ea0:	ea000011 	b	1c001eec <interrupt_security_configall+0x60>
		int_dist->ICDISRx[num_regs] = 0xFFFFFFFF;
1c001ea4:	e3033018 	movw	r3, #12312	; 0x3018
1c001ea8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001eac:	e5933000 	ldr	r3, [r3]
1c001eb0:	e51b2008 	ldr	r2, [fp, #-8]
1c001eb4:	e2822020 	add	r2, r2, #32
1c001eb8:	e3e01000 	mvn	r1, #0
1c001ebc:	e7831102 	str	r1, [r3, r2, lsl #2]
		int_dist->ICDIPRx[num_regs] = 0x80808080;
1c001ec0:	e3033018 	movw	r3, #12312	; 0x3018
1c001ec4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001ec8:	e5932000 	ldr	r2, [r3]
1c001ecc:	e51b3008 	ldr	r3, [fp, #-8]
1c001ed0:	e2831c01 	add	r1, r3, #256	; 0x100
1c001ed4:	e3083080 	movw	r3, #32896	; 0x8080
1c001ed8:	e3483080 	movt	r3, #32896	; 0x8080
1c001edc:	e7823101 	str	r3, [r2, r1, lsl #2]
	for(num_regs=0; num_regs < GIC_NUM_REGISTERS; num_regs++){
1c001ee0:	e51b3008 	ldr	r3, [fp, #-8]
1c001ee4:	e2833001 	add	r3, r3, #1
1c001ee8:	e50b3008 	str	r3, [fp, #-8]
1c001eec:	e51b3008 	ldr	r3, [fp, #-8]
1c001ef0:	e3530002 	cmp	r3, #2
1c001ef4:	9affffea 	bls	1c001ea4 <interrupt_security_configall+0x18>
	}

}
1c001ef8:	e320f000 	nop	{0}
1c001efc:	e24bd000 	sub	sp, fp, #0
1c001f00:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001f04:	e12fff1e 	bx	lr

1c001f08 <interrupt_security_config>:
 * @param	interrupt = interrupt number
 * 		security = security state (NS or S)	
 *
 * @retval	 	
 */
void interrupt_security_config(uint32_t interrupt, IntSecurity_TypeDef security){
1c001f08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001f0c:	e28db000 	add	fp, sp, #0
1c001f10:	e24dd014 	sub	sp, sp, #20
1c001f14:	e50b0010 	str	r0, [fp, #-16]
1c001f18:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

	uint32_t word, temp;

	/* Calculate interrupt position in register */
	word = interrupt / 32;
1c001f1c:	e51b3010 	ldr	r3, [fp, #-16]
1c001f20:	e1a032a3 	lsr	r3, r3, #5
1c001f24:	e50b300c 	str	r3, [fp, #-12]
	interrupt %= 32;
1c001f28:	e51b3010 	ldr	r3, [fp, #-16]
1c001f2c:	e203301f 	and	r3, r3, #31
1c001f30:	e50b3010 	str	r3, [fp, #-16]
	interrupt = 1 << interrupt;
1c001f34:	e3a02001 	mov	r2, #1
1c001f38:	e51b3010 	ldr	r3, [fp, #-16]
1c001f3c:	e1a03312 	lsl	r3, r2, r3
1c001f40:	e50b3010 	str	r3, [fp, #-16]

	temp = int_dist->ICDISRx[word];
1c001f44:	e3033018 	movw	r3, #12312	; 0x3018
1c001f48:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001f4c:	e5933000 	ldr	r3, [r3]
1c001f50:	e51b200c 	ldr	r2, [fp, #-12]
1c001f54:	e2822020 	add	r2, r2, #32
1c001f58:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c001f5c:	e50b3008 	str	r3, [fp, #-8]
	if (security == Int_NS){
1c001f60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c001f64:	e3530001 	cmp	r3, #1
1c001f68:	1a000004 	bne	1c001f80 <interrupt_security_config+0x78>
		temp |= interrupt;
1c001f6c:	e51b2008 	ldr	r2, [fp, #-8]
1c001f70:	e51b3010 	ldr	r3, [fp, #-16]
1c001f74:	e1823003 	orr	r3, r2, r3
1c001f78:	e50b3008 	str	r3, [fp, #-8]
1c001f7c:	ea000004 	b	1c001f94 <interrupt_security_config+0x8c>
	}
	else{
		temp &= ~interrupt;
1c001f80:	e51b3010 	ldr	r3, [fp, #-16]
1c001f84:	e1e03003 	mvn	r3, r3
1c001f88:	e51b2008 	ldr	r2, [fp, #-8]
1c001f8c:	e0033002 	and	r3, r3, r2
1c001f90:	e50b3008 	str	r3, [fp, #-8]
	}
	int_dist->ICDISRx[word] = temp;
1c001f94:	e3033018 	movw	r3, #12312	; 0x3018
1c001f98:	e3413c00 	movt	r3, #7168	; 0x1c00
1c001f9c:	e5933000 	ldr	r3, [r3]
1c001fa0:	e51b200c 	ldr	r2, [fp, #-12]
1c001fa4:	e2822020 	add	r2, r2, #32
1c001fa8:	e51b1008 	ldr	r1, [fp, #-8]
1c001fac:	e7831102 	str	r1, [r3, r2, lsl #2]
}
1c001fb0:	e320f000 	nop	{0}
1c001fb4:	e24bd000 	sub	sp, fp, #0
1c001fb8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001fbc:	e12fff1e 	bx	lr

1c001fc0 <interrupt_number_get>:
 *
 * @param
 *
 * @retval	Return the number of current interrupt	 	
 */
uint32_t interrupt_number_get() {
1c001fc0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001fc4:	e28db000 	add	fp, sp, #0

	return cpu_inter->ICCIAR;
1c001fc8:	e3a03c01 	mov	r3, #256	; 0x100
1c001fcc:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001fd0:	e593300c 	ldr	r3, [r3, #12]
}
1c001fd4:	e1a00003 	mov	r0, r3
1c001fd8:	e24bd000 	sub	sp, fp, #0
1c001fdc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c001fe0:	e12fff1e 	bx	lr

1c001fe4 <interrupt_critical_entry>:
 *
 * @param
 *
 * @retval		
 */
void interrupt_critical_entry() {
1c001fe4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c001fe8:	e28db000 	add	fp, sp, #0
	/* Set higher priority to 0x00 */
	cpu_inter->ICCPMR = 0x00;
1c001fec:	e3a03c01 	mov	r3, #256	; 0x100
1c001ff0:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c001ff4:	e3a02000 	mov	r2, #0
1c001ff8:	e5832004 	str	r2, [r3, #4]
}
1c001ffc:	e320f000 	nop	{0}
1c002000:	e24bd000 	sub	sp, fp, #0
1c002004:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002008:	e12fff1e 	bx	lr

1c00200c <interrupt_critical_exit>:
 *
 * @param
 *
 * @retval		
 */
void interrupt_critical_exit() {
1c00200c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002010:	e28db000 	add	fp, sp, #0
	/* Set higher priority to 0xF0 */
	cpu_inter->ICCPMR = 0xF0;
1c002014:	e3a03c01 	mov	r3, #256	; 0x100
1c002018:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1c00201c:	e3a020f0 	mov	r2, #240	; 0xf0
1c002020:	e5832004 	str	r2, [r3, #4]
}
1c002024:	e320f000 	nop	{0}
1c002028:	e24bd000 	sub	sp, fp, #0
1c00202c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002030:	e12fff1e 	bx	lr

1c002034 <interrupt_IPI_generate>:
 * @param	id = IPI identifier
 *		target = target CPU
 *
 * @retval		
 */
void interrupt_IPI_generate(uint32_t id, uint32_t target){
1c002034:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002038:	e28db000 	add	fp, sp, #0
1c00203c:	e24dd00c 	sub	sp, sp, #12
1c002040:	e50b0008 	str	r0, [fp, #-8]
1c002044:	e50b100c 	str	r1, [fp, #-12]
	/* Software Generated Interrupt Register */
   	int_dist->ICDSGIR = (target << IPI_TARGET_SHIFT) | id;		
1c002048:	e3033018 	movw	r3, #12312	; 0x3018
1c00204c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002050:	e5933000 	ldr	r3, [r3]
1c002054:	e51b200c 	ldr	r2, [fp, #-12]
1c002058:	e1a01802 	lsl	r1, r2, #16
1c00205c:	e51b2008 	ldr	r2, [fp, #-8]
1c002060:	e1812002 	orr	r2, r1, r2
1c002064:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
}
1c002068:	e320f000 	nop	{0}
1c00206c:	e24bd000 	sub	sp, fp, #0
1c002070:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002074:	e12fff1e 	bx	lr

1c002078 <board_init>:
 *
 * @param  	
 *
 * @retval 	
 */
uint32_t board_init(void){
1c002078:	e92d4800 	push	{fp, lr}
1c00207c:	e28db004 	add	fp, sp, #4

	/** Unlocking SLCR register */
	write32( (void *)SLCR_UNLOCK, SLCR_UNLOCK_KEY);
1c002080:	e30d1f0d 	movw	r1, #57101	; 0xdf0d
1c002084:	e3a00008 	mov	r0, #8
1c002088:	e34f0800 	movt	r0, #63488	; 0xf800
1c00208c:	ebfffcb9 	bl	1c001378 <write32>

	/** Handling memory security */
	write32( (void *)TZ_OCM_RAM0, 0xffffffff);
1c002090:	e3e01000 	mvn	r1, #0
1c002094:	e3a00b01 	mov	r0, #1024	; 0x400
1c002098:	e34f0800 	movt	r0, #63488	; 0xf800
1c00209c:	ebfffcb5 	bl	1c001378 <write32>
	write32( (void *)TZ_OCM_RAM1, 0xffffffff);
1c0020a0:	e3e01000 	mvn	r1, #0
1c0020a4:	e3000404 	movw	r0, #1028	; 0x404
1c0020a8:	e34f0800 	movt	r0, #63488	; 0xf800
1c0020ac:	ebfffcb1 	bl	1c001378 <write32>
	write32( (void *)TZ_OCM, 0xffffffff);
1c0020b0:	e3e01000 	mvn	r1, #0
1c0020b4:	e3000408 	movw	r0, #1032	; 0x408
1c0020b8:	e34f0800 	movt	r0, #63488	; 0xf800
1c0020bc:	ebfffcad 	bl	1c001378 <write32>
	/* Handling DDR memory security (first 14segments NS)l */
	write32( (void *)TZ_DDR_RAM, 0x0000007f);
1c0020c0:	e3a0107f 	mov	r1, #127	; 0x7f
1c0020c4:	e3a00e43 	mov	r0, #1072	; 0x430
1c0020c8:	e34f0800 	movt	r0, #63488	; 0xf800
1c0020cc:	ebfffca9 	bl	1c001378 <write32>
	printk("      * Memory security - OK  \n\t");
1c0020d0:	e30305b4 	movw	r0, #13748	; 0x35b4
1c0020d4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c0020d8:	ebfffc86 	bl	1c0012f8 <printk>

	/** Handling devices security */
	/* SDIO0 slave security (NS) */
	write32( (void *)SECURITY2_SDIO0, 0x1);
1c0020dc:	e3a01001 	mov	r1, #1
1c0020e0:	e3a00008 	mov	r0, #8
1c0020e4:	e34e0020 	movt	r0, #57376	; 0xe020
1c0020e8:	ebfffca2 	bl	1c001378 <write32>
	/* SDIO1 slave security (NS) */
	write32( (void *)SECURITY3_SDIO1, 0x1);
1c0020ec:	e3a01001 	mov	r1, #1
1c0020f0:	e3a0000c 	mov	r0, #12
1c0020f4:	e34e0020 	movt	r0, #57376	; 0xe020
1c0020f8:	ebfffc9e 	bl	1c001378 <write32>
	/* QSPI slave security (NS) */
	write32( (void *)SECURITY4_QSPI, 0x1);
1c0020fc:	e3a01001 	mov	r1, #1
1c002100:	e3a00010 	mov	r0, #16
1c002104:	e34e0020 	movt	r0, #57376	; 0xe020
1c002108:	ebfffc9a 	bl	1c001378 <write32>
	/* APB slave security (NS) */
	write32( (void *) SECURITY6_APBSL, 0x00007fff);
1c00210c:	e3071fff 	movw	r1, #32767	; 0x7fff
1c002110:	e3a00018 	mov	r0, #24
1c002114:	e34e0020 	movt	r0, #57376	; 0xe020
1c002118:	ebfffc96 	bl	1c001378 <write32>
	/* DMA slave security (S) */
	write32( (void *)TZ_DMA_NS, 0x0);
1c00211c:	e3a01000 	mov	r1, #0
1c002120:	e3a00d11 	mov	r0, #1088	; 0x440
1c002124:	e34f0800 	movt	r0, #63488	; 0xf800
1c002128:	ebfffc92 	bl	1c001378 <write32>
	write32( (void *)TZ_DMA_IRQ_NS, 0x0);
1c00212c:	e3a01000 	mov	r1, #0
1c002130:	e3000444 	movw	r0, #1092	; 0x444
1c002134:	e34f0800 	movt	r0, #63488	; 0xf800
1c002138:	ebfffc8e 	bl	1c001378 <write32>
	/* Ethernet security */
	write32( (void *)TZ_GEM, 0x3);
1c00213c:	e3a01003 	mov	r1, #3
1c002140:	e3a00e45 	mov	r0, #1104	; 0x450
1c002144:	e34f0800 	movt	r0, #63488	; 0xf800
1c002148:	ebfffc8a 	bl	1c001378 <write32>
	/* FPGA AFI AXI ports TrustZone */
	write32( (void *)SECURITY_APB, 0x3F);
1c00214c:	e3a0103f 	mov	r1, #63	; 0x3f
1c002150:	e3a00028 	mov	r0, #40	; 0x28
1c002154:	e34f0890 	movt	r0, #63632	; 0xf890
1c002158:	ebfffc86 	bl	1c001378 <write32>
	/* Handling more devices ... */
	printk("      * Devices security - OK  \n\t");
1c00215c:	e30305d8 	movw	r0, #13784	; 0x35d8
1c002160:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002164:	ebfffc63 	bl	1c0012f8 <printk>

	/** Locking SLCR register */
	write32( (void *)SLCR_LOCK, SLCR_LOCK_KEY);
1c002168:	e307167b 	movw	r1, #30331	; 0x767b
1c00216c:	e3a00004 	mov	r0, #4
1c002170:	e34f0800 	movt	r0, #63488	; 0xf800
1c002174:	ebfffc7f 	bl	1c001378 <write32>

	return TRUE;
1c002178:	e3a03001 	mov	r3, #1
}
1c00217c:	e1a00003 	mov	r0, r3
1c002180:	e8bd8800 	pop	{fp, pc}

1c002184 <board_handler>:
 * @param  	
 *
 * @retval 	
 */
uint32_t board_handler(uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3)
{
1c002184:	e92d4800 	push	{fp, lr}
1c002188:	e28db004 	add	fp, sp, #4
1c00218c:	e24dd010 	sub	sp, sp, #16
1c002190:	e50b0008 	str	r0, [fp, #-8]
1c002194:	e50b100c 	str	r1, [fp, #-12]
1c002198:	e50b2010 	str	r2, [fp, #-16]
1c00219c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	switch(arg0) {
1c0021a0:	e51b3008 	ldr	r3, [fp, #-8]
1c0021a4:	e373001f 	cmn	r3, #31
1c0021a8:	0a000007 	beq	1c0021cc <board_handler+0x48>
1c0021ac:	e373001e 	cmn	r3, #30
1c0021b0:	0a000000 	beq	1c0021b8 <board_handler+0x34>
			write32( (volatile void*)arg1, arg2);
			break;
		}
		default:

			break;
1c0021b4:	ea000009 	b	1c0021e0 <board_handler+0x5c>
			arg0 = read32((volatile void*)arg1);
1c0021b8:	e51b300c 	ldr	r3, [fp, #-12]
1c0021bc:	e1a00003 	mov	r0, r3
1c0021c0:	ebfffc62 	bl	1c001350 <read32>
1c0021c4:	e50b0008 	str	r0, [fp, #-8]
			break;
1c0021c8:	ea000004 	b	1c0021e0 <board_handler+0x5c>
			write32( (volatile void*)arg1, arg2);
1c0021cc:	e51b300c 	ldr	r3, [fp, #-12]
1c0021d0:	e51b1010 	ldr	r1, [fp, #-16]
1c0021d4:	e1a00003 	mov	r0, r3
1c0021d8:	ebfffc66 	bl	1c001378 <write32>
			break;
1c0021dc:	e320f000 	nop	{0}
	}

		return arg0;
1c0021e0:	e51b3008 	ldr	r3, [fp, #-8]
}
1c0021e4:	e1a00003 	mov	r0, r3
1c0021e8:	e24bd004 	sub	sp, fp, #4
1c0021ec:	e8bd8800 	pop	{fp, pc}

1c0021f0 <uart_init>:
 *
 * @param 	uart_id = ID uart	
 *
 * @retval	TRUE in sucess; FALSE in case error	
 */
uint32_t uart_init(uint8_t uart_id){
1c0021f0:	e92d4800 	push	{fp, lr}
1c0021f4:	e28db004 	add	fp, sp, #4
1c0021f8:	e24dd010 	sub	sp, sp, #16
1c0021fc:	e1a03000 	mov	r3, r0
1c002200:	e54b300d 	strb	r3, [fp, #-13]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c002204:	e55b200d 	ldrb	r2, [fp, #-13]
1c002208:	e30335fc 	movw	r3, #13820	; 0x35fc
1c00220c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002210:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002214:	e50b3008 	str	r3, [fp, #-8]
	uint32_t ret;
	
	ret = uart_set_baud_rate(uart_id, UART_BAUD_RATE);
1c002218:	e55b300d 	ldrb	r3, [fp, #-13]
1c00221c:	e3a01cc2 	mov	r1, #49664	; 0xc200
1c002220:	e3401001 	movt	r1, #1
1c002224:	e1a00003 	mov	r0, r3
1c002228:	eb000047 	bl	1c00234c <uart_set_baud_rate>
1c00222c:	e50b000c 	str	r0, [fp, #-12]
	if(ret == FALSE){
1c002230:	e51b300c 	ldr	r3, [fp, #-12]
1c002234:	e3530000 	cmp	r3, #0
1c002238:	1a000001 	bne	1c002244 <uart_init+0x54>
		return FALSE;
1c00223c:	e3a03000 	mov	r3, #0
1c002240:	ea000012 	b	1c002290 <uart_init+0xa0>
	}

	/* Set the level of the RxFIFO trigger level */
	ptr_uart->rx_fifo_trig = UART_RX_TRIGGER_LVL;
1c002244:	e51b3008 	ldr	r3, [fp, #-8]
1c002248:	e3a02001 	mov	r2, #1
1c00224c:	e5832020 	str	r2, [r3, #32]
	/* Program the Receiver Timeout Mechanism (Disabled) */
	ptr_uart->rx_timeout = UART_RX_TIMEOUT_DIS;
1c002250:	e51b3008 	ldr	r3, [fp, #-8]
1c002254:	e3a02000 	mov	r2, #0
1c002258:	e583201c 	str	r2, [r3, #28]

	/* Clear all the interrupts in Interrupt Status Register */
	ptr_uart->isr_status = 0xFFFFFFFF;
1c00225c:	e51b3008 	ldr	r3, [fp, #-8]
1c002260:	e3e02000 	mvn	r2, #0
1c002264:	e5832014 	str	r2, [r3, #20]
	/* Enable RxFIFO Trigger Interrupt */
	ptr_uart->isr_en = UART_ISR_EN_RTRIG;
1c002268:	e51b3008 	ldr	r3, [fp, #-8]
1c00226c:	e3a02001 	mov	r2, #1
1c002270:	e5832008 	str	r2, [r3, #8]

	/** Enable the Controller */
	ptr_uart->control |= (UART_CONTROL_STPBRK|UART_CONTROL_RXRES|UART_CONTROL_TXRES);
1c002274:	e51b3008 	ldr	r3, [fp, #-8]
1c002278:	e5933000 	ldr	r3, [r3]
1c00227c:	e3833c01 	orr	r3, r3, #256	; 0x100
1c002280:	e3833003 	orr	r3, r3, #3
1c002284:	e51b2008 	ldr	r2, [fp, #-8]
1c002288:	e5823000 	str	r3, [r2]

	return TRUE;
1c00228c:	e3a03001 	mov	r3, #1
}
1c002290:	e1a00003 	mov	r0, r3
1c002294:	e24bd004 	sub	sp, fp, #4
1c002298:	e8bd8800 	pop	{fp, pc}

1c00229c <uart_enable>:
 *
 * @param 	uart_id = ID uart	
 *
 * @retval	
 */
void uart_enable(uint8_t uart_id){
1c00229c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0022a0:	e28db000 	add	fp, sp, #0
1c0022a4:	e24dd014 	sub	sp, sp, #20
1c0022a8:	e1a03000 	mov	r3, r0
1c0022ac:	e54b300d 	strb	r3, [fp, #-13]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c0022b0:	e55b200d 	ldrb	r2, [fp, #-13]
1c0022b4:	e30335fc 	movw	r3, #13820	; 0x35fc
1c0022b8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0022bc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0022c0:	e50b3008 	str	r3, [fp, #-8]

	uint32_t ctrl_reg = ptr_uart->control;
1c0022c4:	e51b3008 	ldr	r3, [fp, #-8]
1c0022c8:	e5933000 	ldr	r3, [r3]
1c0022cc:	e50b300c 	str	r3, [fp, #-12]
	ctrl_reg = ( UART_CONTROL_STPBRK | UART_CONTROL_TXEN | 
1c0022d0:	e3003117 	movw	r3, #279	; 0x117
1c0022d4:	e50b300c 	str	r3, [fp, #-12]
			UART_CONTROL_RXEN | UART_CONTROL_RXRES | UART_CONTROL_TXRES );
	ptr_uart->control = ctrl_reg;
1c0022d8:	e51b3008 	ldr	r3, [fp, #-8]
1c0022dc:	e51b200c 	ldr	r2, [fp, #-12]
1c0022e0:	e5832000 	str	r2, [r3]

}
1c0022e4:	e320f000 	nop	{0}
1c0022e8:	e24bd000 	sub	sp, fp, #0
1c0022ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0022f0:	e12fff1e 	bx	lr

1c0022f4 <uart_disable>:
 *
 * @param 	uart_id = ID uart	
 *
 * @retval	
 */
void uart_disable(uint8_t uart_id){
1c0022f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0022f8:	e28db000 	add	fp, sp, #0
1c0022fc:	e24dd014 	sub	sp, sp, #20
1c002300:	e1a03000 	mov	r3, r0
1c002304:	e54b300d 	strb	r3, [fp, #-13]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c002308:	e55b200d 	ldrb	r2, [fp, #-13]
1c00230c:	e30335fc 	movw	r3, #13820	; 0x35fc
1c002310:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002314:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002318:	e50b3008 	str	r3, [fp, #-8]

	uint32_t ctrl_reg = ptr_uart->control;
1c00231c:	e51b3008 	ldr	r3, [fp, #-8]
1c002320:	e5933000 	ldr	r3, [r3]
1c002324:	e50b300c 	str	r3, [fp, #-12]
	ctrl_reg = ( UART_CONTROL_STPBRK | UART_CONTROL_TXDIS | UART_CONTROL_RXDIS );
1c002328:	e3a03f4a 	mov	r3, #296	; 0x128
1c00232c:	e50b300c 	str	r3, [fp, #-12]
	ptr_uart->control = ctrl_reg;
1c002330:	e51b3008 	ldr	r3, [fp, #-8]
1c002334:	e51b200c 	ldr	r2, [fp, #-12]
1c002338:	e5832000 	str	r2, [r3]
}
1c00233c:	e320f000 	nop	{0}
1c002340:	e24bd000 	sub	sp, fp, #0
1c002344:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002348:	e12fff1e 	bx	lr

1c00234c <uart_set_baud_rate>:
 * @param 	uart_id = ID uart
 *		baud_rate = baudrate speed of the uart	
 *
 * @retval	TRUE in sucess; FALSE in case error	
 */
uint32_t uart_set_baud_rate(uint8_t uart_id, uint32_t baud_rate){
1c00234c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002350:	e28db000 	add	fp, sp, #0
1c002354:	e24dd014 	sub	sp, sp, #20
1c002358:	e1a03000 	mov	r3, r0
1c00235c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
1c002360:	e54b300d 	strb	r3, [fp, #-13]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c002364:	e55b200d 	ldrb	r2, [fp, #-13]
1c002368:	e30335fc 	movw	r3, #13820	; 0x35fc
1c00236c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002370:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002374:	e50b3008 	str	r3, [fp, #-8]

	//uint32_t sel_clk =  UART_FREQ_CLK;
	uint8_t  bdiv = 0;
1c002378:	e3a03000 	mov	r3, #0
1c00237c:	e54b3009 	strb	r3, [fp, #-9]
	uint16_t cd_calc = 0;
1c002380:	e3a03000 	mov	r3, #0
1c002384:	e14b30bc 	strh	r3, [fp, #-12]

	/** Handling corner case */
	if(baud_rate == 0){
1c002388:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c00238c:	e3530000 	cmp	r3, #0
1c002390:	1a000002 	bne	1c0023a0 <uart_set_baud_rate+0x54>
		baud_rate =  UART_BAUD_RATE;
1c002394:	e3a03cc2 	mov	r3, #49664	; 0xc200
1c002398:	e3403001 	movt	r3, #1
1c00239c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	 * sel_clk -> Selected Clock
	 * CD -> Baud Rate Generator
	 * BDIV -> Baud Rate Divider
	 */
	/** FIXME - Handling statically 115200 */
	bdiv = UART_BDIV_115200;
1c0023a0:	e3a03005 	mov	r3, #5
1c0023a4:	e54b3009 	strb	r3, [fp, #-9]
	cd_calc = UART_CD_115200;
1c0023a8:	e3a03048 	mov	r3, #72	; 0x48
1c0023ac:	e14b30bc 	strh	r3, [fp, #-12]
	
	/** Configure the Baud Rate */
	/* Disable the Rx and Tx path */
	ptr_uart->control = (UART_CONTROL_RXDIS|UART_CONTROL_TXDIS);
1c0023b0:	e51b3008 	ldr	r3, [fp, #-8]
1c0023b4:	e3a02028 	mov	r2, #40	; 0x28
1c0023b8:	e5832000 	str	r2, [r3]
	/* Write the calculated CD value */
	ptr_uart->br_gen = cd_calc;
1c0023bc:	e15b20bc 	ldrh	r2, [fp, #-12]
1c0023c0:	e51b3008 	ldr	r3, [fp, #-8]
1c0023c4:	e5832018 	str	r2, [r3, #24]
	/* Write the calculated BDIV value */
	ptr_uart->br_div = bdiv;
1c0023c8:	e55b2009 	ldrb	r2, [fp, #-9]
1c0023cc:	e51b3008 	ldr	r3, [fp, #-8]
1c0023d0:	e5832034 	str	r2, [r3, #52]	; 0x34
	/* Reset Tx and Rx paths */
	ptr_uart->control = (UART_CONTROL_TXRES|UART_CONTROL_RXRES);
1c0023d4:	e51b3008 	ldr	r3, [fp, #-8]
1c0023d8:	e3a02003 	mov	r2, #3
1c0023dc:	e5832000 	str	r2, [r3]
	/* Enable the Rx and Tx path */
	ptr_uart->control = (UART_CONTROL_TXEN|UART_CONTROL_RXEN);
1c0023e0:	e51b3008 	ldr	r3, [fp, #-8]
1c0023e4:	e3a02014 	mov	r2, #20
1c0023e8:	e5832000 	str	r2, [r3]

	return TRUE;
1c0023ec:	e3a03001 	mov	r3, #1
}
1c0023f0:	e1a00003 	mov	r0, r3
1c0023f4:	e24bd000 	sub	sp, fp, #0
1c0023f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0023fc:	e12fff1e 	bx	lr

1c002400 <uart_getc>:
 * @param 	uart_id = ID uart
 *		baud_rate = baudrate speed of the uart	
 *
 * @retval	Received character	
 */
uint32_t uart_getc(uint8_t uart_id){
1c002400:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002404:	e28db000 	add	fp, sp, #0
1c002408:	e24dd014 	sub	sp, sp, #20
1c00240c:	e1a03000 	mov	r3, r0
1c002410:	e54b300d 	strb	r3, [fp, #-13]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c002414:	e55b200d 	ldrb	r2, [fp, #-13]
1c002418:	e30335fc 	movw	r3, #13820	; 0x35fc
1c00241c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002420:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002424:	e50b3008 	str	r3, [fp, #-8]
	uint32_t data = 0;
1c002428:	e3a03000 	mov	r3, #0
1c00242c:	e50b300c 	str	r3, [fp, #-12]

	/* Wait until RxFIFO is filled up to the trigger level */
	while(!ptr_uart->ch_status & UART_CH_STATUS_RTRIG);
1c002430:	e320f000 	nop	{0}
1c002434:	e51b3008 	ldr	r3, [fp, #-8]
1c002438:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1c00243c:	e3530000 	cmp	r3, #0
1c002440:	0afffffb 	beq	1c002434 <uart_getc+0x34>

	data = ptr_uart->tx_rx_fifo;
1c002444:	e51b3008 	ldr	r3, [fp, #-8]
1c002448:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1c00244c:	e50b300c 	str	r3, [fp, #-12]

	return data;
1c002450:	e51b300c 	ldr	r3, [fp, #-12]
}
1c002454:	e1a00003 	mov	r0, r3
1c002458:	e24bd000 	sub	sp, fp, #0
1c00245c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002460:	e12fff1e 	bx	lr

1c002464 <uart_putc>:
 * @param 	uart_id = ID uart
 *		c = Character to be sent 
 *
 * @retval		
 */
void uart_putc(uint8_t uart_id,int8_t c){
1c002464:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002468:	e28db000 	add	fp, sp, #0
1c00246c:	e24dd014 	sub	sp, sp, #20
1c002470:	e1a03000 	mov	r3, r0
1c002474:	e1a02001 	mov	r2, r1
1c002478:	e54b300d 	strb	r3, [fp, #-13]
1c00247c:	e1a03002 	mov	r3, r2
1c002480:	e54b300e 	strb	r3, [fp, #-14]

	Uart_Zynq * ptr_uart = Ptr_Uart[uart_id];
1c002484:	e55b200d 	ldrb	r2, [fp, #-13]
1c002488:	e30335fc 	movw	r3, #13820	; 0x35fc
1c00248c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002490:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002494:	e50b3008 	str	r3, [fp, #-8]

	//wait until txFIFO is not full
	while(ptr_uart->ch_status & UART_CH_STATUS_TFUL);
1c002498:	e320f000 	nop	{0}
1c00249c:	e51b3008 	ldr	r3, [fp, #-8]
1c0024a0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1c0024a4:	e2033010 	and	r3, r3, #16
1c0024a8:	e3530000 	cmp	r3, #0
1c0024ac:	1afffffa 	bne	1c00249c <uart_putc+0x38>

	ptr_uart->tx_rx_fifo = c;
1c0024b0:	e15b20de 	ldrsb	r2, [fp, #-14]
1c0024b4:	e51b3008 	ldr	r3, [fp, #-8]
1c0024b8:	e5832030 	str	r2, [r3, #48]	; 0x30

}
1c0024bc:	e320f000 	nop	{0}
1c0024c0:	e24bd000 	sub	sp, fp, #0
1c0024c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c0024c8:	e12fff1e 	bx	lr

1c0024cc <uart_puts>:
 * @param 	uart_id = ID uart
 *		c = String to be sent 
 *
 * @retval		
 */
void uart_puts(uint8_t uart_id, const int8_t *s){
1c0024cc:	e92d4800 	push	{fp, lr}
1c0024d0:	e28db004 	add	fp, sp, #4
1c0024d4:	e24dd008 	sub	sp, sp, #8
1c0024d8:	e1a03000 	mov	r3, r0
1c0024dc:	e50b100c 	str	r1, [fp, #-12]
1c0024e0:	e54b3005 	strb	r3, [fp, #-5]

	 while (*s){
1c0024e4:	ea000007 	b	1c002508 <uart_puts+0x3c>
		uart_putc(uart_id,*s++);
1c0024e8:	e51b300c 	ldr	r3, [fp, #-12]
1c0024ec:	e2832001 	add	r2, r3, #1
1c0024f0:	e50b200c 	str	r2, [fp, #-12]
1c0024f4:	e1d320d0 	ldrsb	r2, [r3]
1c0024f8:	e55b3005 	ldrb	r3, [fp, #-5]
1c0024fc:	e1a01002 	mov	r1, r2
1c002500:	e1a00003 	mov	r0, r3
1c002504:	ebffffd6 	bl	1c002464 <uart_putc>
	 while (*s){
1c002508:	e51b300c 	ldr	r3, [fp, #-12]
1c00250c:	e1d330d0 	ldrsb	r3, [r3]
1c002510:	e3530000 	cmp	r3, #0
1c002514:	1afffff3 	bne	1c0024e8 <uart_puts+0x1c>
	}
}
1c002518:	e320f000 	nop	{0}
1c00251c:	e24bd004 	sub	sp, fp, #4
1c002520:	e8bd8800 	pop	{fp, pc}

1c002524 <ttc_init>:
 * 		timer_num = TTC's timer number
 * 		mode = timer mode 	
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t ttc_init(uint32_t ttc_num, uint32_t timer_num, uint32_t mode){
1c002524:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002528:	e28db000 	add	fp, sp, #0
1c00252c:	e24dd01c 	sub	sp, sp, #28
1c002530:	e50b0010 	str	r0, [fp, #-16]
1c002534:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
1c002538:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8

	Zynq_Ttc * ptr_ttc = NULL;
1c00253c:	e3a03000 	mov	r3, #0
1c002540:	e50b3008 	str	r3, [fp, #-8]
	uint32_t clk_cntrl = 0;
1c002544:	e3a03000 	mov	r3, #0
1c002548:	e50b300c 	str	r3, [fp, #-12]

	/**  Check Arguments  */
	if( (ttc_num > TTC1) || (timer_num > TTCx_2) || (mode > FREE_RUNNING) ){
1c00254c:	e51b3010 	ldr	r3, [fp, #-16]
1c002550:	e3530001 	cmp	r3, #1
1c002554:	8a000005 	bhi	1c002570 <ttc_init+0x4c>
1c002558:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c00255c:	e3530001 	cmp	r3, #1
1c002560:	8a000002 	bhi	1c002570 <ttc_init+0x4c>
1c002564:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c002568:	e3530002 	cmp	r3, #2
1c00256c:	9a000001 	bls	1c002578 <ttc_init+0x54>
		/* Invalid Argument */
		return (FALSE); 
1c002570:	e3a03000 	mov	r3, #0
1c002574:	ea000044 	b	1c00268c <ttc_init+0x168>
	}

	ptr_ttc = Ptr_Ttc[ttc_num];
1c002578:	e3033604 	movw	r3, #13828	; 0x3604
1c00257c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002580:	e51b2010 	ldr	r2, [fp, #-16]
1c002584:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002588:	e50b3008 	str	r3, [fp, #-8]

	/** Reset Configuration Value */
	ptr_ttc->cnt_cntrl[timer_num] = TTC_RESET_CONFIG; // Reset Configs
1c00258c:	e51b2008 	ldr	r2, [fp, #-8]
1c002590:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c002594:	e2833002 	add	r3, r3, #2
1c002598:	e1a03103 	lsl	r3, r3, #2
1c00259c:	e0823003 	add	r3, r2, r3
1c0025a0:	e3a02021 	mov	r2, #33	; 0x21
1c0025a4:	e5832004 	str	r2, [r3, #4]

	/** Set clock input source */
	clk_cntrl = ptr_ttc->clk_cntrl[timer_num];
1c0025a8:	e51b3008 	ldr	r3, [fp, #-8]
1c0025ac:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c0025b0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0025b4:	e50b300c 	str	r3, [fp, #-12]
	/* Prescale disable -> F = 111MHz (1us = 111ticks) */
	clk_cntrl &= (~(TTC_CLK_CNTRL_PS_EN));
1c0025b8:	e51b300c 	ldr	r3, [fp, #-12]
1c0025bc:	e3c33001 	bic	r3, r3, #1
1c0025c0:	e50b300c 	str	r3, [fp, #-12]
	ptr_ttc->clk_cntrl[timer_num] = clk_cntrl;
1c0025c4:	e51b3008 	ldr	r3, [fp, #-8]
1c0025c8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c0025cc:	e51b100c 	ldr	r1, [fp, #-12]
1c0025d0:	e7831102 	str	r1, [r3, r2, lsl #2]

	/** Set Configurations */
	switch (mode){
1c0025d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c0025d8:	e3530001 	cmp	r3, #1
1c0025dc:	0a000017 	beq	1c002640 <ttc_init+0x11c>
1c0025e0:	e3530001 	cmp	r3, #1
1c0025e4:	3a000001 	bcc	1c0025f0 <ttc_init+0xcc>
1c0025e8:	e3530002 	cmp	r3, #2
			/* Set match1 interrupt */ 
			ptr_ttc->interrupt_en[timer_num] = TTC_INT_EN_MATCH1; 
			break;
		case FREE_RUNNING:
			/* Nothing to do */
			break;
1c0025ec:	ea000025 	b	1c002688 <ttc_init+0x164>
			ptr_ttc->cnt_cntrl[timer_num] = (TTC_RESET_CONFIG) | (TTC_CNT_CNTRL_RST | TTC_CNT_CNTRL_INT | TTC_CNT_CNTRL_DIS);
1c0025f0:	e51b2008 	ldr	r2, [fp, #-8]
1c0025f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0025f8:	e2833002 	add	r3, r3, #2
1c0025fc:	e1a03103 	lsl	r3, r3, #2
1c002600:	e0823003 	add	r3, r2, r3
1c002604:	e3a02033 	mov	r2, #51	; 0x33
1c002608:	e5832004 	str	r2, [r3, #4]
			ptr_ttc->interv_cnt[timer_num] = TTC_INT_VALUE; 
1c00260c:	e51b2008 	ldr	r2, [fp, #-8]
1c002610:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c002614:	e2833008 	add	r3, r3, #8
1c002618:	e1a03103 	lsl	r3, r3, #2
1c00261c:	e0823003 	add	r3, r2, r3
1c002620:	e3a02064 	mov	r2, #100	; 0x64
1c002624:	e5832004 	str	r2, [r3, #4]
			ptr_ttc->interrupt_en[timer_num] = TTC_INT_EN_INTERVAL; 
1c002628:	e51b3008 	ldr	r3, [fp, #-8]
1c00262c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c002630:	e2822018 	add	r2, r2, #24
1c002634:	e3a01001 	mov	r1, #1
1c002638:	e7831102 	str	r1, [r3, r2, lsl #2]
			break;
1c00263c:	ea000011 	b	1c002688 <ttc_init+0x164>
			ptr_ttc->cnt_cntrl[timer_num] = (TTC_CNT_CNTRL_RST | TTC_CNT_CNTRL_MATCH | TTC_CNT_CNTRL_DIS);
1c002640:	e51b2008 	ldr	r2, [fp, #-8]
1c002644:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c002648:	e2833002 	add	r3, r3, #2
1c00264c:	e1a03103 	lsl	r3, r3, #2
1c002650:	e0823003 	add	r3, r2, r3
1c002654:	e3a02019 	mov	r2, #25
1c002658:	e5832004 	str	r2, [r3, #4]
			ptr_ttc->match1_cnt[timer_num] = TTC_MATCH1_VALUE;
1c00265c:	e51b3008 	ldr	r3, [fp, #-8]
1c002660:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c002664:	e282200c 	add	r2, r2, #12
1c002668:	e3a01064 	mov	r1, #100	; 0x64
1c00266c:	e7831102 	str	r1, [r3, r2, lsl #2]
			ptr_ttc->interrupt_en[timer_num] = TTC_INT_EN_MATCH1; 
1c002670:	e51b3008 	ldr	r3, [fp, #-8]
1c002674:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
1c002678:	e2822018 	add	r2, r2, #24
1c00267c:	e3a01002 	mov	r1, #2
1c002680:	e7831102 	str	r1, [r3, r2, lsl #2]
			break;
1c002684:	e320f000 	nop	{0}
	}

	return TRUE;
1c002688:	e3a03001 	mov	r3, #1
}
1c00268c:	e1a00003 	mov	r0, r3
1c002690:	e24bd000 	sub	sp, fp, #0
1c002694:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002698:	e12fff1e 	bx	lr

1c00269c <ttc_enable>:
 * @param 	ttc_num = TTC number
 * 		timer_num = TTC's timer number
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t ttc_enable(uint32_t ttc_num, uint32_t timer_num){
1c00269c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c0026a0:	e28db000 	add	fp, sp, #0
1c0026a4:	e24dd014 	sub	sp, sp, #20
1c0026a8:	e50b0010 	str	r0, [fp, #-16]
1c0026ac:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

	Zynq_Ttc * ptr_ttc = NULL;
1c0026b0:	e3a03000 	mov	r3, #0
1c0026b4:	e50b3008 	str	r3, [fp, #-8]
	uint32_t cnt_cntrl = 0;
1c0026b8:	e3a03000 	mov	r3, #0
1c0026bc:	e50b300c 	str	r3, [fp, #-12]

	/**  Check Arguments  */
	if( (ttc_num > TTC1) || (timer_num > TTCx_2)){
1c0026c0:	e51b3010 	ldr	r3, [fp, #-16]
1c0026c4:	e3530001 	cmp	r3, #1
1c0026c8:	8a000002 	bhi	1c0026d8 <ttc_enable+0x3c>
1c0026cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0026d0:	e3530001 	cmp	r3, #1
1c0026d4:	9a000001 	bls	1c0026e0 <ttc_enable+0x44>
		/* Invalid Argument */
		return (FALSE); 
1c0026d8:	e3a03000 	mov	r3, #0
1c0026dc:	ea000019 	b	1c002748 <ttc_enable+0xac>
	}

	ptr_ttc = Ptr_Ttc[ttc_num];
1c0026e0:	e3033604 	movw	r3, #13828	; 0x3604
1c0026e4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0026e8:	e51b2010 	ldr	r2, [fp, #-16]
1c0026ec:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0026f0:	e50b3008 	str	r3, [fp, #-8]

	cnt_cntrl = ptr_ttc->cnt_cntrl[timer_num]; 
1c0026f4:	e51b2008 	ldr	r2, [fp, #-8]
1c0026f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0026fc:	e2833002 	add	r3, r3, #2
1c002700:	e1a03103 	lsl	r3, r3, #2
1c002704:	e0823003 	add	r3, r2, r3
1c002708:	e5933004 	ldr	r3, [r3, #4]
1c00270c:	e50b300c 	str	r3, [fp, #-12]
	/* Reset counter value and restarts counting */
	cnt_cntrl |= TTC_CNT_CNTRL_RST;
1c002710:	e51b300c 	ldr	r3, [fp, #-12]
1c002714:	e3833010 	orr	r3, r3, #16
1c002718:	e50b300c 	str	r3, [fp, #-12]
	/* Enable Timer */ 
	cnt_cntrl &= ~TTC_CNT_CNTRL_DIS; 
1c00271c:	e51b300c 	ldr	r3, [fp, #-12]
1c002720:	e3c33001 	bic	r3, r3, #1
1c002724:	e50b300c 	str	r3, [fp, #-12]
	ptr_ttc->cnt_cntrl[timer_num] = cnt_cntrl;
1c002728:	e51b2008 	ldr	r2, [fp, #-8]
1c00272c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c002730:	e2833002 	add	r3, r3, #2
1c002734:	e1a03103 	lsl	r3, r3, #2
1c002738:	e0823003 	add	r3, r2, r3
1c00273c:	e51b200c 	ldr	r2, [fp, #-12]
1c002740:	e5832004 	str	r2, [r3, #4]

	return TRUE;
1c002744:	e3a03001 	mov	r3, #1
}
1c002748:	e1a00003 	mov	r0, r3
1c00274c:	e24bd000 	sub	sp, fp, #0
1c002750:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002754:	e12fff1e 	bx	lr

1c002758 <ttc_disable>:
 * @param 	ttc_num = TTC number
 * 		timer_num = TTC's timer number
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t ttc_disable(uint32_t ttc_num, uint32_t timer_num){
1c002758:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c00275c:	e28db000 	add	fp, sp, #0
1c002760:	e24dd014 	sub	sp, sp, #20
1c002764:	e50b0010 	str	r0, [fp, #-16]
1c002768:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

	Zynq_Ttc * ptr_ttc = NULL;
1c00276c:	e3a03000 	mov	r3, #0
1c002770:	e50b3008 	str	r3, [fp, #-8]
	uint32_t cnt_cntrl = 0;
1c002774:	e3a03000 	mov	r3, #0
1c002778:	e50b300c 	str	r3, [fp, #-12]

	/**  Check Arguments  */
	if( (ttc_num > TTC1) || (timer_num > TTCx_2)){
1c00277c:	e51b3010 	ldr	r3, [fp, #-16]
1c002780:	e3530001 	cmp	r3, #1
1c002784:	8a000002 	bhi	1c002794 <ttc_disable+0x3c>
1c002788:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c00278c:	e3530001 	cmp	r3, #1
1c002790:	9a000001 	bls	1c00279c <ttc_disable+0x44>
		/* Invalid Argument */
		return (FALSE); 
1c002794:	e3a03000 	mov	r3, #0
1c002798:	ea000016 	b	1c0027f8 <ttc_disable+0xa0>
	}

	ptr_ttc = Ptr_Ttc[ttc_num];
1c00279c:	e3033604 	movw	r3, #13828	; 0x3604
1c0027a0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c0027a4:	e51b2010 	ldr	r2, [fp, #-16]
1c0027a8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0027ac:	e50b3008 	str	r3, [fp, #-8]

	cnt_cntrl = ptr_ttc->cnt_cntrl[timer_num];
1c0027b0:	e51b2008 	ldr	r2, [fp, #-8]
1c0027b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0027b8:	e2833002 	add	r3, r3, #2
1c0027bc:	e1a03103 	lsl	r3, r3, #2
1c0027c0:	e0823003 	add	r3, r2, r3
1c0027c4:	e5933004 	ldr	r3, [r3, #4]
1c0027c8:	e50b300c 	str	r3, [fp, #-12]
	/* Disable Timer */
	cnt_cntrl |= TTC_CNT_CNTRL_DIS; 
1c0027cc:	e51b300c 	ldr	r3, [fp, #-12]
1c0027d0:	e3833001 	orr	r3, r3, #1
1c0027d4:	e50b300c 	str	r3, [fp, #-12]
	ptr_ttc->cnt_cntrl[timer_num] = cnt_cntrl;
1c0027d8:	e51b2008 	ldr	r2, [fp, #-8]
1c0027dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
1c0027e0:	e2833002 	add	r3, r3, #2
1c0027e4:	e1a03103 	lsl	r3, r3, #2
1c0027e8:	e0823003 	add	r3, r2, r3
1c0027ec:	e51b200c 	ldr	r2, [fp, #-12]
1c0027f0:	e5832004 	str	r2, [r3, #4]

	return TRUE;
1c0027f4:	e3a03001 	mov	r3, #1
}
1c0027f8:	e1a00003 	mov	r0, r3
1c0027fc:	e24bd000 	sub	sp, fp, #0
1c002800:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002804:	e12fff1e 	bx	lr

1c002808 <ttc_request>:
 * 		timer_num = TTC's timer number
 *		useconds = time 
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t ttc_request(uint32_t ttc_num, uint32_t timer_num, uint32_t useconds){
1c002808:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c00280c:	e28db000 	add	fp, sp, #0
1c002810:	e24dd024 	sub	sp, sp, #36	; 0x24
1c002814:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
1c002818:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
1c00281c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0

	Zynq_Ttc * ptr_ttc = NULL;
1c002820:	e3a03000 	mov	r3, #0
1c002824:	e50b3008 	str	r3, [fp, #-8]
	uint32_t cnt_cntrl = 0;
1c002828:	e3a03000 	mov	r3, #0
1c00282c:	e50b300c 	str	r3, [fp, #-12]
	uint32_t clk_cntrl = 0;
1c002830:	e3a03000 	mov	r3, #0
1c002834:	e50b3010 	str	r3, [fp, #-16]

	/**  Check Arguments  */
	if( (ttc_num > TTC1) || (timer_num > TTCx_2)){
1c002838:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c00283c:	e3530001 	cmp	r3, #1
1c002840:	8a000002 	bhi	1c002850 <ttc_request+0x48>
1c002844:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c002848:	e3530001 	cmp	r3, #1
1c00284c:	9a000001 	bls	1c002858 <ttc_request+0x50>
		/* Invalid Argument */
		return (FALSE); 
1c002850:	e3a03000 	mov	r3, #0
1c002854:	ea000069 	b	1c002a00 <ttc_request+0x1f8>
	}

	ptr_ttc = Ptr_Ttc[ttc_num];
1c002858:	e3033604 	movw	r3, #13828	; 0x3604
1c00285c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002860:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
1c002864:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002868:	e50b3008 	str	r3, [fp, #-8]

	/** Reset counter value and restarts counting */
	cnt_cntrl = ptr_ttc->cnt_cntrl[timer_num];
1c00286c:	e51b2008 	ldr	r2, [fp, #-8]
1c002870:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c002874:	e2833002 	add	r3, r3, #2
1c002878:	e1a03103 	lsl	r3, r3, #2
1c00287c:	e0823003 	add	r3, r2, r3
1c002880:	e5933004 	ldr	r3, [r3, #4]
1c002884:	e50b300c 	str	r3, [fp, #-12]
	cnt_cntrl |= ( TTC_CNT_CNTRL_RST | TTC_CNT_CNTRL_DIS );
1c002888:	e51b300c 	ldr	r3, [fp, #-12]
1c00288c:	e3833011 	orr	r3, r3, #17
1c002890:	e50b300c 	str	r3, [fp, #-12]
	ptr_ttc->cnt_cntrl[timer_num] = cnt_cntrl;
1c002894:	e51b2008 	ldr	r2, [fp, #-8]
1c002898:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c00289c:	e2833002 	add	r3, r3, #2
1c0028a0:	e1a03103 	lsl	r3, r3, #2
1c0028a4:	e0823003 	add	r3, r2, r3
1c0028a8:	e51b200c 	ldr	r2, [fp, #-12]
1c0028ac:	e5832004 	str	r2, [r3, #4]

	/** Static handling - range [1us;1ms]*/
	/* TODO - redo */
	if( useconds>=1 && useconds<=1000 ) {
1c0028b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c0028b4:	e3530000 	cmp	r3, #0
1c0028b8:	0a000016 	beq	1c002918 <ttc_request+0x110>
1c0028bc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c0028c0:	e3530ffa 	cmp	r3, #1000	; 0x3e8
1c0028c4:	8a000013 	bhi	1c002918 <ttc_request+0x110>
		/* Prescaler = 1 -> F = 100MHz/(2^(1+1)) (1ms = 25000 ticks) */
		clk_cntrl = ptr_ttc->clk_cntrl[timer_num];
1c0028c8:	e51b3008 	ldr	r3, [fp, #-8]
1c0028cc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c0028d0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c0028d4:	e50b3010 	str	r3, [fp, #-16]
		clk_cntrl |= ( ((2-1) << 1) | 0x1 );			/* Prescaler = 1 */
1c0028d8:	e51b3010 	ldr	r3, [fp, #-16]
1c0028dc:	e3833003 	orr	r3, r3, #3
1c0028e0:	e50b3010 	str	r3, [fp, #-16]
		ptr_ttc->clk_cntrl[timer_num] = clk_cntrl;
1c0028e4:	e51b3008 	ldr	r3, [fp, #-8]
1c0028e8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c0028ec:	e51b1010 	ldr	r1, [fp, #-16]
1c0028f0:	e7831102 	str	r1, [r3, r2, lsl #2]

		useconds = ((useconds * 25000) / 1000);
1c0028f4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c0028f8:	e30621a8 	movw	r2, #25000	; 0x61a8
1c0028fc:	e0020392 	mul	r2, r2, r3
1c002900:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1c002904:	e3413062 	movt	r3, #4194	; 0x1062
1c002908:	e0832392 	umull	r2, r3, r2, r3
1c00290c:	e1a03323 	lsr	r3, r3, #6
1c002910:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
1c002914:	ea00001d 	b	1c002990 <ttc_request+0x188>
	}
	/** Static handling - range ]1ms;1s]*/
	/* TODO - redo */
	else if (useconds>1000 && useconds<=1000000) {
1c002918:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c00291c:	e3530ffa 	cmp	r3, #1000	; 0x3e8
1c002920:	9a000018 	bls	1c002988 <ttc_request+0x180>
1c002924:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
1c002928:	e3043240 	movw	r3, #16960	; 0x4240
1c00292c:	e340300f 	movt	r3, #15
1c002930:	e1520003 	cmp	r2, r3
1c002934:	8a000013 	bhi	1c002988 <ttc_request+0x180>
		/* Prescaler = 11 -> F = 100MHz/(2^(11+1)) (10ms = 244 ticks) */
		clk_cntrl = ptr_ttc->clk_cntrl[timer_num];
1c002938:	e51b3008 	ldr	r3, [fp, #-8]
1c00293c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c002940:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002944:	e50b3010 	str	r3, [fp, #-16]
		clk_cntrl |= ( ((12-1) << 1) | 0x1 );			/* Prescaler = 11 */
1c002948:	e51b3010 	ldr	r3, [fp, #-16]
1c00294c:	e3833017 	orr	r3, r3, #23
1c002950:	e50b3010 	str	r3, [fp, #-16]
		ptr_ttc->clk_cntrl[timer_num] = clk_cntrl;
1c002954:	e51b3008 	ldr	r3, [fp, #-8]
1c002958:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c00295c:	e51b1010 	ldr	r1, [fp, #-16]
1c002960:	e7831102 	str	r1, [r3, r2, lsl #2]

		useconds = ((useconds * 244) / 10000);
1c002964:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
1c002968:	e3a020f4 	mov	r2, #244	; 0xf4
1c00296c:	e0020392 	mul	r2, r2, r3
1c002970:	e3013759 	movw	r3, #5977	; 0x1759
1c002974:	e34d31b7 	movt	r3, #53687	; 0xd1b7
1c002978:	e0832392 	umull	r2, r3, r2, r3
1c00297c:	e1a036a3 	lsr	r3, r3, #13
1c002980:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
1c002984:	ea000001 	b	1c002990 <ttc_request+0x188>

	} 
	else{
		return (FALSE); 
1c002988:	e3a03000 	mov	r3, #0
1c00298c:	ea00001b 	b	1c002a00 <ttc_request+0x1f8>
	}

	/** Set Time */
	/* Extract mode */
	cnt_cntrl &= (TTC_CNT_CNTRL_MATCH | TTC_CNT_CNTRL_INT); 
1c002990:	e51b300c 	ldr	r3, [fp, #-12]
1c002994:	e203300a 	and	r3, r3, #10
1c002998:	e50b300c 	str	r3, [fp, #-12]
	/* Interval Mode */
	if(cnt_cntrl & TTC_CNT_CNTRL_INT){
1c00299c:	e51b300c 	ldr	r3, [fp, #-12]
1c0029a0:	e2033002 	and	r3, r3, #2
1c0029a4:	e3530000 	cmp	r3, #0
1c0029a8:	0a000007 	beq	1c0029cc <ttc_request+0x1c4>
		ptr_ttc->interv_cnt[timer_num] = useconds;
1c0029ac:	e51b2008 	ldr	r2, [fp, #-8]
1c0029b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
1c0029b4:	e2833008 	add	r3, r3, #8
1c0029b8:	e1a03103 	lsl	r3, r3, #2
1c0029bc:	e0823003 	add	r3, r2, r3
1c0029c0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
1c0029c4:	e5832004 	str	r2, [r3, #4]
1c0029c8:	ea00000b 	b	1c0029fc <ttc_request+0x1f4>
	}
	/* Match Mode */
	else if(cnt_cntrl & TTC_CNT_CNTRL_MATCH){
1c0029cc:	e51b300c 	ldr	r3, [fp, #-12]
1c0029d0:	e2033008 	and	r3, r3, #8
1c0029d4:	e3530000 	cmp	r3, #0
1c0029d8:	0a000005 	beq	1c0029f4 <ttc_request+0x1ec>
		ptr_ttc->match1_cnt[timer_num] = useconds;
1c0029dc:	e51b3008 	ldr	r3, [fp, #-8]
1c0029e0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
1c0029e4:	e282200c 	add	r2, r2, #12
1c0029e8:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
1c0029ec:	e7831102 	str	r1, [r3, r2, lsl #2]
1c0029f0:	ea000001 	b	1c0029fc <ttc_request+0x1f4>
	}
	else{
		/* Not Implemented */
		return FALSE; 
1c0029f4:	e3a03000 	mov	r3, #0
1c0029f8:	ea000000 	b	1c002a00 <ttc_request+0x1f8>
	}

	return TRUE;
1c0029fc:	e3a03001 	mov	r3, #1
}
1c002a00:	e1a00003 	mov	r0, r3
1c002a04:	e24bd000 	sub	sp, fp, #0
1c002a08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002a0c:	e12fff1e 	bx	lr

1c002a10 <ttc_interrupt_clear>:
 *
 * @param 	interrupt = interrupt number 
 *
 * @retval	True for success and FALSE in case ERROR 	
 */
uint32_t ttc_interrupt_clear(uint32_t interrupt){
1c002a10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002a14:	e28db000 	add	fp, sp, #0
1c002a18:	e24dd01c 	sub	sp, sp, #28
1c002a1c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8

	Zynq_Ttc * ptr_ttc = NULL;
1c002a20:	e3a03000 	mov	r3, #0
1c002a24:	e50b3010 	str	r3, [fp, #-16]
	uint32_t ttc_num = 0;
1c002a28:	e3a03000 	mov	r3, #0
1c002a2c:	e50b3008 	str	r3, [fp, #-8]
	uint32_t interrupt_reg = 0;
1c002a30:	e3a03000 	mov	r3, #0
1c002a34:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	uint32_t ttc_tim_num = 0;
1c002a38:	e3a03000 	mov	r3, #0
1c002a3c:	e50b300c 	str	r3, [fp, #-12]

	/** Check which TTC_timer generated the Interrupt */
	switch (interrupt){
1c002a40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
1c002a44:	e243302a 	sub	r3, r3, #42	; 0x2a
1c002a48:	e353001d 	cmp	r3, #29
1c002a4c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1c002a50:	ea00003b 	b	1c002b44 <ttc_interrupt_clear+0x134>
1c002a54:	1c002acc 	.word	0x1c002acc
1c002a58:	1c002ae0 	.word	0x1c002ae0
1c002a5c:	1c002af4 	.word	0x1c002af4
1c002a60:	1c002b44 	.word	0x1c002b44
1c002a64:	1c002b44 	.word	0x1c002b44
1c002a68:	1c002b44 	.word	0x1c002b44
1c002a6c:	1c002b44 	.word	0x1c002b44
1c002a70:	1c002b44 	.word	0x1c002b44
1c002a74:	1c002b44 	.word	0x1c002b44
1c002a78:	1c002b44 	.word	0x1c002b44
1c002a7c:	1c002b44 	.word	0x1c002b44
1c002a80:	1c002b44 	.word	0x1c002b44
1c002a84:	1c002b44 	.word	0x1c002b44
1c002a88:	1c002b44 	.word	0x1c002b44
1c002a8c:	1c002b44 	.word	0x1c002b44
1c002a90:	1c002b44 	.word	0x1c002b44
1c002a94:	1c002b44 	.word	0x1c002b44
1c002a98:	1c002b44 	.word	0x1c002b44
1c002a9c:	1c002b44 	.word	0x1c002b44
1c002aa0:	1c002b44 	.word	0x1c002b44
1c002aa4:	1c002b44 	.word	0x1c002b44
1c002aa8:	1c002b44 	.word	0x1c002b44
1c002aac:	1c002b44 	.word	0x1c002b44
1c002ab0:	1c002b44 	.word	0x1c002b44
1c002ab4:	1c002b44 	.word	0x1c002b44
1c002ab8:	1c002b44 	.word	0x1c002b44
1c002abc:	1c002b44 	.word	0x1c002b44
1c002ac0:	1c002b08 	.word	0x1c002b08
1c002ac4:	1c002b1c 	.word	0x1c002b1c
1c002ac8:	1c002b30 	.word	0x1c002b30
		case TTC0_TTCx_1_INTERRUPT:
			ttc_num = 0;
1c002acc:	e3a03000 	mov	r3, #0
1c002ad0:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 0;
1c002ad4:	e3a03000 	mov	r3, #0
1c002ad8:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002adc:	ea00001a 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		case TTC0_TTCx_2_INTERRUPT:
			ttc_num = 0;
1c002ae0:	e3a03000 	mov	r3, #0
1c002ae4:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 1;
1c002ae8:	e3a03001 	mov	r3, #1
1c002aec:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002af0:	ea000015 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		case TTC0_TTCx_3_INTERRUPT:
			ttc_num = 0;
1c002af4:	e3a03000 	mov	r3, #0
1c002af8:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 2;
1c002afc:	e3a03002 	mov	r3, #2
1c002b00:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002b04:	ea000010 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		case TTC1_TTCx_1_INTERRUPT:
			ttc_num = 1;
1c002b08:	e3a03001 	mov	r3, #1
1c002b0c:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 0;
1c002b10:	e3a03000 	mov	r3, #0
1c002b14:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002b18:	ea00000b 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		case TTC1_TTCx_2_INTERRUPT:
			ttc_num = 1;
1c002b1c:	e3a03001 	mov	r3, #1
1c002b20:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 1;
1c002b24:	e3a03001 	mov	r3, #1
1c002b28:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002b2c:	ea000006 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		case TTC1_TTCx_3_INTERRUPT:
			ttc_num = 1;
1c002b30:	e3a03001 	mov	r3, #1
1c002b34:	e50b3008 	str	r3, [fp, #-8]
			ttc_tim_num = 2;
1c002b38:	e3a03002 	mov	r3, #2
1c002b3c:	e50b300c 	str	r3, [fp, #-12]
			break;
1c002b40:	ea000001 	b	1c002b4c <ttc_interrupt_clear+0x13c>
		default:
			/* ERROR */
			return FALSE;
1c002b44:	e3a03000 	mov	r3, #0
1c002b48:	ea00000c 	b	1c002b80 <ttc_interrupt_clear+0x170>
	}

	ptr_ttc = Ptr_Ttc[ttc_num];
1c002b4c:	e3033604 	movw	r3, #13828	; 0x3604
1c002b50:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002b54:	e51b2008 	ldr	r2, [fp, #-8]
1c002b58:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1c002b5c:	e50b3010 	str	r3, [fp, #-16]

	/** Clear Interrupt Status Flag */
	interrupt_reg = ptr_ttc->interrupt_reg[ttc_tim_num];
1c002b60:	e51b2010 	ldr	r2, [fp, #-16]
1c002b64:	e51b300c 	ldr	r3, [fp, #-12]
1c002b68:	e2833014 	add	r3, r3, #20
1c002b6c:	e1a03103 	lsl	r3, r3, #2
1c002b70:	e0823003 	add	r3, r2, r3
1c002b74:	e5933004 	ldr	r3, [r3, #4]
1c002b78:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	return interrupt_reg;
1c002b7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
1c002b80:	e1a00003 	mov	r0, r3
1c002b84:	e24bd000 	sub	sp, fp, #0
1c002b88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002b8c:	e12fff1e 	bx	lr

1c002b90 <ltzvisor_hw_init>:
 *
 * @param  
 *
 * @retval Return TRUE if success or False if not
 */
uint32_t ltzvisor_hw_init(void){
1c002b90:	e92d4800 	push	{fp, lr}
1c002b94:	e28db004 	add	fp, sp, #4
1c002b98:	e24dd008 	sub	sp, sp, #8

	uint32_t ret = TRUE;
1c002b9c:	e3a03001 	mov	r3, #1
1c002ba0:	e50b300c 	str	r3, [fp, #-12]
	uint32_t i;

	/** Init Serial Port */
	for(i=0; i<10000; i++); //Comment if not running with U-boot
1c002ba4:	e3a03000 	mov	r3, #0
1c002ba8:	e50b3008 	str	r3, [fp, #-8]
1c002bac:	ea000002 	b	1c002bbc <ltzvisor_hw_init+0x2c>
1c002bb0:	e51b3008 	ldr	r3, [fp, #-8]
1c002bb4:	e2833001 	add	r3, r3, #1
1c002bb8:	e50b3008 	str	r3, [fp, #-8]
1c002bbc:	e51b3008 	ldr	r3, [fp, #-8]
1c002bc0:	e302270f 	movw	r2, #9999	; 0x270f
1c002bc4:	e1530002 	cmp	r3, r2
1c002bc8:	9afffff8 	bls	1c002bb0 <ltzvisor_hw_init+0x20>
	ret = uart_init(1);
1c002bcc:	e3a00001 	mov	r0, #1
1c002bd0:	ebfffd86 	bl	1c0021f0 <uart_init>
1c002bd4:	e50b000c 	str	r0, [fp, #-12]
	if(!ret){
1c002bd8:	e51b300c 	ldr	r3, [fp, #-12]
1c002bdc:	e3530000 	cmp	r3, #0
1c002be0:	1a000001 	bne	1c002bec <ltzvisor_hw_init+0x5c>
		/* ERROR */
		/* FIXME - Signal Error somewhere (LED) */
		return ret;
1c002be4:	e51b300c 	ldr	r3, [fp, #-12]
1c002be8:	ea000053 	b	1c002d3c <ltzvisor_hw_init+0x1ac>
	}

	printk("\n\n\t");
1c002bec:	e303060c 	movw	r0, #13836	; 0x360c
1c002bf0:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002bf4:	ebfff9bf 	bl	1c0012f8 <printk>
	printk("----------------------------------------------------------\n\t");
1c002bf8:	e3030610 	movw	r0, #13840	; 0x3610
1c002bfc:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c00:	ebfff9bc 	bl	1c0012f8 <printk>
	printk("                 LTZVisor (version %s)        \n\t", VERSION);
1c002c04:	e3031650 	movw	r1, #13904	; 0x3650
1c002c08:	e3411c00 	movt	r1, #7168	; 0x1c00
1c002c0c:	e3030658 	movw	r0, #13912	; 0x3658
1c002c10:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c14:	ebfff9b7 	bl	1c0012f8 <printk>
	printk("----------------------------------------------------------\n\t");
1c002c18:	e3030610 	movw	r0, #13840	; 0x3610
1c002c1c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c20:	ebfff9b4 	bl	1c0012f8 <printk>
	printk(" -> Arch (%s): CPU (%s) initialization ... \n\t", ARCH, CPU);
1c002c24:	e303268c 	movw	r2, #13964	; 0x368c
1c002c28:	e3412c00 	movt	r2, #7168	; 0x1c00
1c002c2c:	e3031698 	movw	r1, #13976	; 0x3698
1c002c30:	e3411c00 	movt	r1, #7168	; 0x1c00
1c002c34:	e30306a0 	movw	r0, #13984	; 0x36a0
1c002c38:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c3c:	ebfff9ad 	bl	1c0012f8 <printk>
	printk(" -> Arch (%s): GIC initialization ... \n\t", ARCH);
1c002c40:	e3031698 	movw	r1, #13976	; 0x3698
1c002c44:	e3411c00 	movt	r1, #7168	; 0x1c00
1c002c48:	e30306d0 	movw	r0, #14032	; 0x36d0
1c002c4c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c50:	ebfff9a8 	bl	1c0012f8 <printk>

	/** Initialize GIC Distributer and GIC Interface*/
	/* Distributor init */
	ret = interrupt_distributor_init();
1c002c54:	ebfffaf2 	bl	1c001824 <interrupt_distributor_init>
1c002c58:	e50b000c 	str	r0, [fp, #-12]
	if(!ret){
1c002c5c:	e51b300c 	ldr	r3, [fp, #-12]
1c002c60:	e3530000 	cmp	r3, #0
1c002c64:	1a000004 	bne	1c002c7c <ltzvisor_hw_init+0xec>

		/* ERROR */
		printk("ERROR: GIC distributor init!\n\r");
1c002c68:	e30306fc 	movw	r0, #14076	; 0x36fc
1c002c6c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c70:	ebfff9a0 	bl	1c0012f8 <printk>
		return ret;
1c002c74:	e51b300c 	ldr	r3, [fp, #-12]
1c002c78:	ea00002f 	b	1c002d3c <ltzvisor_hw_init+0x1ac>
	}
	printk("      * GIC distributor - OK  \n\t");
1c002c7c:	e303071c 	movw	r0, #14108	; 0x371c
1c002c80:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002c84:	ebfff99b 	bl	1c0012f8 <printk>
	/* Interface init */
	ret = interrupt_interface_init();
1c002c88:	ebfffb92 	bl	1c001ad8 <interrupt_interface_init>
1c002c8c:	e50b000c 	str	r0, [fp, #-12]
	if(!ret){
1c002c90:	e51b300c 	ldr	r3, [fp, #-12]
1c002c94:	e3530000 	cmp	r3, #0
1c002c98:	1a000004 	bne	1c002cb0 <ltzvisor_hw_init+0x120>

		/* ERROR */
		printk("ERROR: GIC interface init!\n\r");
1c002c9c:	e3030740 	movw	r0, #14144	; 0x3740
1c002ca0:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002ca4:	ebfff993 	bl	1c0012f8 <printk>
		return ret;
1c002ca8:	e51b300c 	ldr	r3, [fp, #-12]
1c002cac:	ea000022 	b	1c002d3c <ltzvisor_hw_init+0x1ac>
	}
	printk("      * GIC interface - OK  \n\t");
1c002cb0:	e3030760 	movw	r0, #14176	; 0x3760
1c002cb4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002cb8:	ebfff98e 	bl	1c0012f8 <printk>
	/* Config Interrupts Security */
	interrupt_security_configall();
1c002cbc:	ebfffc72 	bl	1c001e8c <interrupt_security_configall>
	interrupt_security_config(UART_1_INTERRUPT,Int_NS);
1c002cc0:	e3a01001 	mov	r1, #1
1c002cc4:	e3a00052 	mov	r0, #82	; 0x52
1c002cc8:	ebfffc8e 	bl	1c001f08 <interrupt_security_config>
	interrupt_security_config(TTC0_TTCx_1_INTERRUPT,Int_S);
1c002ccc:	e3a01000 	mov	r1, #0
1c002cd0:	e3a0002a 	mov	r0, #42	; 0x2a
1c002cd4:	ebfffc8b 	bl	1c001f08 <interrupt_security_config>
	interrupt_security_config(27,Int_S); //GLOBAL TIMER INTERRUPT
1c002cd8:	e3a01000 	mov	r1, #0
1c002cdc:	e3a0001b 	mov	r0, #27
1c002ce0:	ebfffc88 	bl	1c001f08 <interrupt_security_config>
	interrupt_security_config(0,Int_S); //SGI Interrupt for yield
1c002ce4:	e3a01000 	mov	r1, #0
1c002ce8:	e3a00000 	mov	r0, #0
1c002cec:	ebfffc85 	bl	1c001f08 <interrupt_security_config>
	printk("      * GIC security - OK  \n\t");
1c002cf0:	e3030780 	movw	r0, #14208	; 0x3780
1c002cf4:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002cf8:	ebfff97e 	bl	1c0012f8 <printk>

	/** Initialize Platform-specific */
	printk(" -> Platform (%s): initialization ... \n\t", PLATFORM);
1c002cfc:	e30317a0 	movw	r1, #14240	; 0x37a0
1c002d00:	e3411c00 	movt	r1, #7168	; 0x1c00
1c002d04:	e30307ac 	movw	r0, #14252	; 0x37ac
1c002d08:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002d0c:	ebfff979 	bl	1c0012f8 <printk>
	ret = board_init();
1c002d10:	ebfffcd8 	bl	1c002078 <board_init>
1c002d14:	e50b000c 	str	r0, [fp, #-12]
	if(!ret){
1c002d18:	e51b300c 	ldr	r3, [fp, #-12]
1c002d1c:	e3530000 	cmp	r3, #0
1c002d20:	1a000004 	bne	1c002d38 <ltzvisor_hw_init+0x1a8>
		/* ERROR */
		printk("ERROR: Platform init!\n\r");
1c002d24:	e30307d8 	movw	r0, #14296	; 0x37d8
1c002d28:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002d2c:	ebfff971 	bl	1c0012f8 <printk>
		return ret;
1c002d30:	e51b300c 	ldr	r3, [fp, #-12]
1c002d34:	ea000000 	b	1c002d3c <ltzvisor_hw_init+0x1ac>
	}

	return ret;
1c002d38:	e51b300c 	ldr	r3, [fp, #-12]
}
1c002d3c:	e1a00003 	mov	r0, r3
1c002d40:	e24bd004 	sub	sp, fp, #4
1c002d44:	e8bd8800 	pop	{fp, pc}

1c002d48 <cachel2_init>:

#include <l2_pl310.h>

static volatile CacheL2pl310* l2_pl310 = (CacheL2pl310*) PL310_BASE;

void cachel2_init(){
1c002d48:	e92d4800 	push	{fp, lr}
1c002d4c:	e28db004 	add	fp, sp, #4
1c002d50:	e24dd008 	sub	sp, sp, #8

	write32( (void *)SLCR_UNLOCK, SLCR_UNLOCK_KEY);
1c002d54:	e30d1f0d 	movw	r1, #57101	; 0xdf0d
1c002d58:	e3a00008 	mov	r0, #8
1c002d5c:	e34f0800 	movt	r0, #63488	; 0xf800
1c002d60:	ebfff984 	bl	1c001378 <write32>
    write32( (void *)RESERVED, 0x020202);
1c002d64:	e3001202 	movw	r1, #514	; 0x202
1c002d68:	e3401002 	movt	r1, #2
1c002d6c:	e3000a1c 	movw	r0, #2588	; 0xa1c
1c002d70:	e34f0800 	movt	r0, #63488	; 0xf800
1c002d74:	ebfff97f 	bl	1c001378 <write32>
	write32( (void *)SLCR_LOCK, SLCR_LOCK_KEY);
1c002d78:	e307167b 	movw	r1, #30331	; 0x767b
1c002d7c:	e3a00004 	mov	r0, #4
1c002d80:	e34f0800 	movt	r0, #63488	; 0xf800
1c002d84:	ebfff97b 	bl	1c001378 <write32>

	// setup associativity and size
	printk("default: 0x%x\n\r", l2_pl310->reg1_aux_control);
1c002d88:	e303319c 	movw	r3, #12700	; 0x319c
1c002d8c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002d90:	e5933000 	ldr	r3, [r3]
1c002d94:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002d98:	e1a01003 	mov	r1, r3
1c002d9c:	e30307f0 	movw	r0, #14320	; 0x37f0
1c002da0:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002da4:	ebfff953 	bl	1c0012f8 <printk>

	volatile uint32_t x = l2_pl310->reg1_aux_control;
1c002da8:	e303319c 	movw	r3, #12700	; 0x319c
1c002dac:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002db0:	e5933000 	ldr	r3, [r3]
1c002db4:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002db8:	e50b3008 	str	r3, [fp, #-8]
	l2_pl310->reg1_aux_control &= 0xFFF0EFFF;
1c002dbc:	e303319c 	movw	r3, #12700	; 0x319c
1c002dc0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002dc4:	e5932000 	ldr	r2, [r3]
1c002dc8:	e303319c 	movw	r3, #12700	; 0x319c
1c002dcc:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002dd0:	e5933000 	ldr	r3, [r3]
1c002dd4:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002dd8:	e3c33af1 	bic	r3, r3, #987136	; 0xf1000
1c002ddc:	e5823104 	str	r3, [r2, #260]	; 0x104
	l2_pl310->reg1_aux_control |= (3 << 17); //0x72360000;
1c002de0:	e303319c 	movw	r3, #12700	; 0x319c
1c002de4:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002de8:	e5932000 	ldr	r2, [r3]
1c002dec:	e303319c 	movw	r3, #12700	; 0x319c
1c002df0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002df4:	e5933000 	ldr	r3, [r3]
1c002df8:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002dfc:	e3833806 	orr	r3, r3, #393216	; 0x60000
1c002e00:	e5823104 	str	r3, [r2, #260]	; 0x104
	asm("dsb\nisb\n");
1c002e04:	f57ff04f 	dsb	sy
1c002e08:	f57ff06f 	isb	sy
	printk("8-way: 0x%x\n\r", l2_pl310->reg1_aux_control);
1c002e0c:	e303319c 	movw	r3, #12700	; 0x319c
1c002e10:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e14:	e5933000 	ldr	r3, [r3]
1c002e18:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002e1c:	e1a01003 	mov	r1, r3
1c002e20:	e3030800 	movw	r0, #14336	; 0x3800
1c002e24:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002e28:	ebfff932 	bl	1c0012f8 <printk>

	l2_pl310->reg1_aux_control &= 0xFFF0EFFF;
1c002e2c:	e303319c 	movw	r3, #12700	; 0x319c
1c002e30:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e34:	e5932000 	ldr	r2, [r3]
1c002e38:	e303319c 	movw	r3, #12700	; 0x319c
1c002e3c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e40:	e5933000 	ldr	r3, [r3]
1c002e44:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002e48:	e3c33af1 	bic	r3, r3, #987136	; 0xf1000
1c002e4c:	e5823104 	str	r3, [r2, #260]	; 0x104
	l2_pl310->reg1_aux_control = 0xFFFFFFFF; //0x72360000;
1c002e50:	e303319c 	movw	r3, #12700	; 0x319c
1c002e54:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e58:	e5933000 	ldr	r3, [r3]
1c002e5c:	e3e02000 	mvn	r2, #0
1c002e60:	e5832104 	str	r2, [r3, #260]	; 0x104
	x = l2_pl310->reg1_aux_control;
1c002e64:	e303319c 	movw	r3, #12700	; 0x319c
1c002e68:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e6c:	e5933000 	ldr	r3, [r3]
1c002e70:	e5933104 	ldr	r3, [r3, #260]	; 0x104
1c002e74:	e50b3008 	str	r3, [fp, #-8]
	asm("dsb\nisb\n");
1c002e78:	f57ff04f 	dsb	sy
1c002e7c:	f57ff06f 	isb	sy
	printk("16-way: 0x%x\n\r", x);
1c002e80:	e51b3008 	ldr	r3, [fp, #-8]
1c002e84:	e1a01003 	mov	r1, r3
1c002e88:	e3030810 	movw	r0, #14352	; 0x3810
1c002e8c:	e3410c00 	movt	r0, #7168	; 0x1c00
1c002e90:	ebfff918 	bl	1c0012f8 <printk>

	// setup data and tag latencies (according to ZYNQ TRM)
	l2_pl310->reg1_tag_ram_control = 0x111;
1c002e94:	e303319c 	movw	r3, #12700	; 0x319c
1c002e98:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002e9c:	e5933000 	ldr	r3, [r3]
1c002ea0:	e3002111 	movw	r2, #273	; 0x111
1c002ea4:	e5832108 	str	r2, [r3, #264]	; 0x108
	l2_pl310->reg1_data_ram_control = 0X121;
1c002ea8:	e303319c 	movw	r3, #12700	; 0x319c
1c002eac:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002eb0:	e5933000 	ldr	r3, [r3]
1c002eb4:	e3002121 	movw	r2, #289	; 0x121
1c002eb8:	e583210c 	str	r2, [r3, #268]	; 0x10c

	cachel2_invalidate();
1c002ebc:	eb000030 	bl	1c002f84 <cachel2_invalidate>

	// l2_pl310->reg2_ev_counter0_cfg = 0x02 << 2;	//data read hit
	// l2_pl310->reg2_ev_counter1_cfg = 0x03 << 2;	//data read req
	// l2_pl310->reg2_ev_counter_ctrl |= 0x07;
}
1c002ec0:	e320f000 	nop	{0}
1c002ec4:	e24bd004 	sub	sp, fp, #4
1c002ec8:	e8bd8800 	pop	{fp, pc}

1c002ecc <cachel2_sync>:

static inline void cachel2_sync(){
1c002ecc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002ed0:	e28db000 	add	fp, sp, #0
    l2_pl310->reg7_cache_sync = 0;
1c002ed4:	e303319c 	movw	r3, #12700	; 0x319c
1c002ed8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002edc:	e5933000 	ldr	r3, [r3]
1c002ee0:	e3a02000 	mov	r2, #0
1c002ee4:	e5832730 	str	r2, [r3, #1840]	; 0x730
    while(l2_pl310->reg7_cache_sync);
1c002ee8:	e320f000 	nop	{0}
1c002eec:	e303319c 	movw	r3, #12700	; 0x319c
1c002ef0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002ef4:	e5933000 	ldr	r3, [r3]
1c002ef8:	e5933730 	ldr	r3, [r3, #1840]	; 0x730
1c002efc:	e3530000 	cmp	r3, #0
1c002f00:	1afffff9 	bne	1c002eec <cachel2_sync+0x20>
}
1c002f04:	e320f000 	nop	{0}
1c002f08:	e24bd000 	sub	sp, fp, #0
1c002f0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002f10:	e12fff1e 	bx	lr

1c002f14 <cachel2_enable>:

void cachel2_enable(){
1c002f14:	e92d4800 	push	{fp, lr}
1c002f18:	e28db004 	add	fp, sp, #4
    l2_pl310->reg1_control |= 0x01;
1c002f1c:	e303319c 	movw	r3, #12700	; 0x319c
1c002f20:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002f24:	e5932000 	ldr	r2, [r3]
1c002f28:	e303319c 	movw	r3, #12700	; 0x319c
1c002f2c:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002f30:	e5933000 	ldr	r3, [r3]
1c002f34:	e5933100 	ldr	r3, [r3, #256]	; 0x100
1c002f38:	e3833001 	orr	r3, r3, #1
1c002f3c:	e5823100 	str	r3, [r2, #256]	; 0x100
    cachel2_sync();
1c002f40:	ebffffe1 	bl	1c002ecc <cachel2_sync>
}
1c002f44:	e320f000 	nop	{0}
1c002f48:	e8bd8800 	pop	{fp, pc}

1c002f4c <cachel2_disable>:

void cachel2_disable(){
1c002f4c:	e92d4800 	push	{fp, lr}
1c002f50:	e28db004 	add	fp, sp, #4
    l2_pl310->reg1_control &= ~0x01;
1c002f54:	e303319c 	movw	r3, #12700	; 0x319c
1c002f58:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002f5c:	e5932000 	ldr	r2, [r3]
1c002f60:	e303319c 	movw	r3, #12700	; 0x319c
1c002f64:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002f68:	e5933000 	ldr	r3, [r3]
1c002f6c:	e5933100 	ldr	r3, [r3, #256]	; 0x100
1c002f70:	e3c33001 	bic	r3, r3, #1
1c002f74:	e5823100 	str	r3, [r2, #256]	; 0x100
    cachel2_sync();
1c002f78:	ebffffd3 	bl	1c002ecc <cachel2_sync>
}
1c002f7c:	e320f000 	nop	{0}
1c002f80:	e8bd8800 	pop	{fp, pc}

1c002f84 <cachel2_invalidate>:

void cachel2_invalidate(){
1c002f84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002f88:	e28db000 	add	fp, sp, #0
	l2_pl310->reg7_inv_way = 0xFFFF; //invalidate all ways
1c002f8c:	e303319c 	movw	r3, #12700	; 0x319c
1c002f90:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002f94:	e5933000 	ldr	r3, [r3]
1c002f98:	e30f2fff 	movw	r2, #65535	; 0xffff
1c002f9c:	e583277c 	str	r2, [r3, #1916]	; 0x77c
	while(l2_pl310->reg7_inv_way);
1c002fa0:	e320f000 	nop	{0}
1c002fa4:	e303319c 	movw	r3, #12700	; 0x319c
1c002fa8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002fac:	e5933000 	ldr	r3, [r3]
1c002fb0:	e593377c 	ldr	r3, [r3, #1916]	; 0x77c
1c002fb4:	e3530000 	cmp	r3, #0
1c002fb8:	1afffff9 	bne	1c002fa4 <cachel2_invalidate+0x20>
}
1c002fbc:	e320f000 	nop	{0}
1c002fc0:	e24bd000 	sub	sp, fp, #0
1c002fc4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c002fc8:	e12fff1e 	bx	lr

1c002fcc <cachel2_clean>:

void cachel2_clean(){
1c002fcc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1c002fd0:	e28db000 	add	fp, sp, #0
	l2_pl310->reg7_clean_way = 0xFFFF; //invalidate all ways
1c002fd4:	e303319c 	movw	r3, #12700	; 0x319c
1c002fd8:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002fdc:	e5933000 	ldr	r3, [r3]
1c002fe0:	e30f2fff 	movw	r2, #65535	; 0xffff
1c002fe4:	e58327bc 	str	r2, [r3, #1980]	; 0x7bc
	while(l2_pl310->reg7_clean_way);
1c002fe8:	e320f000 	nop	{0}
1c002fec:	e303319c 	movw	r3, #12700	; 0x319c
1c002ff0:	e3413c00 	movt	r3, #7168	; 0x1c00
1c002ff4:	e5933000 	ldr	r3, [r3]
1c002ff8:	e59337bc 	ldr	r3, [r3, #1980]	; 0x7bc
1c002ffc:	e3530000 	cmp	r3, #0
1c003000:	1afffff9 	bne	1c002fec <cachel2_clean+0x20>
}
1c003004:	e320f000 	nop	{0}
1c003008:	e24bd000 	sub	sp, fp, #0
1c00300c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1c003010:	e12fff1e 	bx	lr
